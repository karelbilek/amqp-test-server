// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/karelbilek/amqp-test-server/amqp/protocol_generated.proto

package amqp

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ConnectionStart struct {
	VersionMajor         byte     `protobuf:"varint,1,opt,name=version_major,json=versionMajor,casttype=byte" json:"version_major"`
	VersionMinor         byte     `protobuf:"varint,2,opt,name=version_minor,json=versionMinor,casttype=byte" json:"version_minor"`
	ServerProperties     *Table   `protobuf:"bytes,3,opt,name=server_properties,json=serverProperties" json:"server_properties,omitempty"`
	Mechanisms           []byte   `protobuf:"bytes,4,opt,name=mechanisms" json:"mechanisms,omitempty"`
	Locales              []byte   `protobuf:"bytes,5,opt,name=locales" json:"locales,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionStart) Reset()         { *m = ConnectionStart{} }
func (m *ConnectionStart) String() string { return proto.CompactTextString(m) }
func (*ConnectionStart) ProtoMessage()    {}
func (*ConnectionStart) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{0}
}
func (m *ConnectionStart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionStart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionStart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionStart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionStart.Merge(m, src)
}
func (m *ConnectionStart) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionStart) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionStart.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionStart proto.InternalMessageInfo

type ConnectionStartOk struct {
	ClientProperties     *Table   `protobuf:"bytes,1,opt,name=client_properties,json=clientProperties" json:"client_properties,omitempty"`
	Mechanism            string   `protobuf:"bytes,2,opt,name=mechanism" json:"mechanism"`
	Response             []byte   `protobuf:"bytes,3,opt,name=response" json:"response,omitempty"`
	Locale               string   `protobuf:"bytes,4,opt,name=locale" json:"locale"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionStartOk) Reset()         { *m = ConnectionStartOk{} }
func (m *ConnectionStartOk) String() string { return proto.CompactTextString(m) }
func (*ConnectionStartOk) ProtoMessage()    {}
func (*ConnectionStartOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{1}
}
func (m *ConnectionStartOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionStartOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionStartOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionStartOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionStartOk.Merge(m, src)
}
func (m *ConnectionStartOk) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionStartOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionStartOk.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionStartOk proto.InternalMessageInfo

type ConnectionSecure struct {
	Challenge            []byte   `protobuf:"bytes,1,opt,name=challenge" json:"challenge,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionSecure) Reset()         { *m = ConnectionSecure{} }
func (m *ConnectionSecure) String() string { return proto.CompactTextString(m) }
func (*ConnectionSecure) ProtoMessage()    {}
func (*ConnectionSecure) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{2}
}
func (m *ConnectionSecure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionSecure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionSecure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionSecure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionSecure.Merge(m, src)
}
func (m *ConnectionSecure) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionSecure) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionSecure.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionSecure proto.InternalMessageInfo

type ConnectionSecureOk struct {
	Response             []byte   `protobuf:"bytes,1,opt,name=response" json:"response,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionSecureOk) Reset()         { *m = ConnectionSecureOk{} }
func (m *ConnectionSecureOk) String() string { return proto.CompactTextString(m) }
func (*ConnectionSecureOk) ProtoMessage()    {}
func (*ConnectionSecureOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{3}
}
func (m *ConnectionSecureOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionSecureOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionSecureOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionSecureOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionSecureOk.Merge(m, src)
}
func (m *ConnectionSecureOk) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionSecureOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionSecureOk.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionSecureOk proto.InternalMessageInfo

type ConnectionTune struct {
	ChannelMax           uint16   `protobuf:"varint,1,opt,name=channel_max,json=channelMax,casttype=uint16" json:"channel_max"`
	FrameMax             uint32   `protobuf:"varint,2,opt,name=frame_max,json=frameMax" json:"frame_max"`
	Heartbeat            uint16   `protobuf:"varint,3,opt,name=heartbeat,casttype=uint16" json:"heartbeat"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionTune) Reset()         { *m = ConnectionTune{} }
func (m *ConnectionTune) String() string { return proto.CompactTextString(m) }
func (*ConnectionTune) ProtoMessage()    {}
func (*ConnectionTune) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{4}
}
func (m *ConnectionTune) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionTune) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionTune.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionTune) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionTune.Merge(m, src)
}
func (m *ConnectionTune) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionTune) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionTune.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionTune proto.InternalMessageInfo

type ConnectionTuneOk struct {
	ChannelMax           uint16   `protobuf:"varint,1,opt,name=channel_max,json=channelMax,casttype=uint16" json:"channel_max"`
	FrameMax             uint32   `protobuf:"varint,2,opt,name=frame_max,json=frameMax" json:"frame_max"`
	Heartbeat            uint16   `protobuf:"varint,3,opt,name=heartbeat,casttype=uint16" json:"heartbeat"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionTuneOk) Reset()         { *m = ConnectionTuneOk{} }
func (m *ConnectionTuneOk) String() string { return proto.CompactTextString(m) }
func (*ConnectionTuneOk) ProtoMessage()    {}
func (*ConnectionTuneOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{5}
}
func (m *ConnectionTuneOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionTuneOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionTuneOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionTuneOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionTuneOk.Merge(m, src)
}
func (m *ConnectionTuneOk) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionTuneOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionTuneOk.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionTuneOk proto.InternalMessageInfo

type ConnectionOpen struct {
	VirtualHost          string   `protobuf:"bytes,1,opt,name=virtual_host,json=virtualHost" json:"virtual_host"`
	Reserved1            string   `protobuf:"bytes,2,opt,name=reserved1" json:"reserved1"`
	Reserved2            bool     `protobuf:"varint,3,opt,name=reserved2" json:"reserved2"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionOpen) Reset()         { *m = ConnectionOpen{} }
func (m *ConnectionOpen) String() string { return proto.CompactTextString(m) }
func (*ConnectionOpen) ProtoMessage()    {}
func (*ConnectionOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{6}
}
func (m *ConnectionOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionOpen.Merge(m, src)
}
func (m *ConnectionOpen) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionOpen.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionOpen proto.InternalMessageInfo

type ConnectionOpenOk struct {
	Reserved1            string   `protobuf:"bytes,1,opt,name=reserved1" json:"reserved1"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionOpenOk) Reset()         { *m = ConnectionOpenOk{} }
func (m *ConnectionOpenOk) String() string { return proto.CompactTextString(m) }
func (*ConnectionOpenOk) ProtoMessage()    {}
func (*ConnectionOpenOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{7}
}
func (m *ConnectionOpenOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionOpenOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionOpenOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionOpenOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionOpenOk.Merge(m, src)
}
func (m *ConnectionOpenOk) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionOpenOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionOpenOk.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionOpenOk proto.InternalMessageInfo

type ConnectionClose struct {
	ReplyCode            uint16   `protobuf:"varint,1,opt,name=reply_code,json=replyCode,casttype=uint16" json:"reply_code"`
	ReplyText            string   `protobuf:"bytes,2,opt,name=reply_text,json=replyText" json:"reply_text"`
	ClassId              uint16   `protobuf:"varint,3,opt,name=class_id,json=classId,casttype=uint16" json:"class_id"`
	MethodId             uint16   `protobuf:"varint,4,opt,name=method_id,json=methodId,casttype=uint16" json:"method_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionClose) Reset()         { *m = ConnectionClose{} }
func (m *ConnectionClose) String() string { return proto.CompactTextString(m) }
func (*ConnectionClose) ProtoMessage()    {}
func (*ConnectionClose) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{8}
}
func (m *ConnectionClose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionClose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionClose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionClose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionClose.Merge(m, src)
}
func (m *ConnectionClose) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionClose) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionClose.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionClose proto.InternalMessageInfo

type ConnectionCloseOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionCloseOk) Reset()         { *m = ConnectionCloseOk{} }
func (m *ConnectionCloseOk) String() string { return proto.CompactTextString(m) }
func (*ConnectionCloseOk) ProtoMessage()    {}
func (*ConnectionCloseOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{9}
}
func (m *ConnectionCloseOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionCloseOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionCloseOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionCloseOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionCloseOk.Merge(m, src)
}
func (m *ConnectionCloseOk) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionCloseOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionCloseOk.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionCloseOk proto.InternalMessageInfo

type ConnectionBlocked struct {
	Reason               string   `protobuf:"bytes,1,opt,name=reason" json:"reason"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionBlocked) Reset()         { *m = ConnectionBlocked{} }
func (m *ConnectionBlocked) String() string { return proto.CompactTextString(m) }
func (*ConnectionBlocked) ProtoMessage()    {}
func (*ConnectionBlocked) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{10}
}
func (m *ConnectionBlocked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionBlocked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionBlocked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionBlocked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionBlocked.Merge(m, src)
}
func (m *ConnectionBlocked) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionBlocked) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionBlocked.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionBlocked proto.InternalMessageInfo

type ConnectionUnblocked struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectionUnblocked) Reset()         { *m = ConnectionUnblocked{} }
func (m *ConnectionUnblocked) String() string { return proto.CompactTextString(m) }
func (*ConnectionUnblocked) ProtoMessage()    {}
func (*ConnectionUnblocked) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{11}
}
func (m *ConnectionUnblocked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectionUnblocked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectionUnblocked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectionUnblocked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionUnblocked.Merge(m, src)
}
func (m *ConnectionUnblocked) XXX_Size() int {
	return m.Size()
}
func (m *ConnectionUnblocked) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionUnblocked.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionUnblocked proto.InternalMessageInfo

type ChannelOpen struct {
	Reserved1            string   `protobuf:"bytes,1,opt,name=reserved1" json:"reserved1"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelOpen) Reset()         { *m = ChannelOpen{} }
func (m *ChannelOpen) String() string { return proto.CompactTextString(m) }
func (*ChannelOpen) ProtoMessage()    {}
func (*ChannelOpen) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{12}
}
func (m *ChannelOpen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelOpen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelOpen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelOpen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelOpen.Merge(m, src)
}
func (m *ChannelOpen) XXX_Size() int {
	return m.Size()
}
func (m *ChannelOpen) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelOpen.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelOpen proto.InternalMessageInfo

type ChannelOpenOk struct {
	Reserved1            []byte   `protobuf:"bytes,1,opt,name=reserved1" json:"reserved1,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelOpenOk) Reset()         { *m = ChannelOpenOk{} }
func (m *ChannelOpenOk) String() string { return proto.CompactTextString(m) }
func (*ChannelOpenOk) ProtoMessage()    {}
func (*ChannelOpenOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{13}
}
func (m *ChannelOpenOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelOpenOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelOpenOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelOpenOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelOpenOk.Merge(m, src)
}
func (m *ChannelOpenOk) XXX_Size() int {
	return m.Size()
}
func (m *ChannelOpenOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelOpenOk.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelOpenOk proto.InternalMessageInfo

type ChannelFlow struct {
	Active               bool     `protobuf:"varint,1,opt,name=active" json:"active"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelFlow) Reset()         { *m = ChannelFlow{} }
func (m *ChannelFlow) String() string { return proto.CompactTextString(m) }
func (*ChannelFlow) ProtoMessage()    {}
func (*ChannelFlow) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{14}
}
func (m *ChannelFlow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelFlow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelFlow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelFlow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelFlow.Merge(m, src)
}
func (m *ChannelFlow) XXX_Size() int {
	return m.Size()
}
func (m *ChannelFlow) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelFlow.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelFlow proto.InternalMessageInfo

type ChannelFlowOk struct {
	Active               bool     `protobuf:"varint,1,opt,name=active" json:"active"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelFlowOk) Reset()         { *m = ChannelFlowOk{} }
func (m *ChannelFlowOk) String() string { return proto.CompactTextString(m) }
func (*ChannelFlowOk) ProtoMessage()    {}
func (*ChannelFlowOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{15}
}
func (m *ChannelFlowOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelFlowOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelFlowOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelFlowOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelFlowOk.Merge(m, src)
}
func (m *ChannelFlowOk) XXX_Size() int {
	return m.Size()
}
func (m *ChannelFlowOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelFlowOk.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelFlowOk proto.InternalMessageInfo

type ChannelClose struct {
	ReplyCode            uint16   `protobuf:"varint,1,opt,name=reply_code,json=replyCode,casttype=uint16" json:"reply_code"`
	ReplyText            string   `protobuf:"bytes,2,opt,name=reply_text,json=replyText" json:"reply_text"`
	ClassId              uint16   `protobuf:"varint,3,opt,name=class_id,json=classId,casttype=uint16" json:"class_id"`
	MethodId             uint16   `protobuf:"varint,4,opt,name=method_id,json=methodId,casttype=uint16" json:"method_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelClose) Reset()         { *m = ChannelClose{} }
func (m *ChannelClose) String() string { return proto.CompactTextString(m) }
func (*ChannelClose) ProtoMessage()    {}
func (*ChannelClose) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{16}
}
func (m *ChannelClose) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelClose) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelClose.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelClose) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelClose.Merge(m, src)
}
func (m *ChannelClose) XXX_Size() int {
	return m.Size()
}
func (m *ChannelClose) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelClose.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelClose proto.InternalMessageInfo

type ChannelCloseOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChannelCloseOk) Reset()         { *m = ChannelCloseOk{} }
func (m *ChannelCloseOk) String() string { return proto.CompactTextString(m) }
func (*ChannelCloseOk) ProtoMessage()    {}
func (*ChannelCloseOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{17}
}
func (m *ChannelCloseOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelCloseOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelCloseOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelCloseOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelCloseOk.Merge(m, src)
}
func (m *ChannelCloseOk) XXX_Size() int {
	return m.Size()
}
func (m *ChannelCloseOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelCloseOk.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelCloseOk proto.InternalMessageInfo

type ExchangeDeclare struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Exchange             string   `protobuf:"bytes,2,opt,name=exchange" json:"exchange"`
	Type                 string   `protobuf:"bytes,3,opt,name=type" json:"type"`
	Passive              bool     `protobuf:"varint,4,opt,name=passive" json:"passive"`
	Durable              bool     `protobuf:"varint,5,opt,name=durable" json:"durable"`
	AutoDelete           bool     `protobuf:"varint,6,opt,name=auto_delete,json=autoDelete" json:"auto_delete"`
	Internal             bool     `protobuf:"varint,7,opt,name=internal" json:"internal"`
	NoWait               bool     `protobuf:"varint,8,opt,name=no_wait,json=noWait" json:"no_wait"`
	Arguments            *Table   `protobuf:"bytes,9,opt,name=arguments" json:"arguments,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeDeclare) Reset()         { *m = ExchangeDeclare{} }
func (m *ExchangeDeclare) String() string { return proto.CompactTextString(m) }
func (*ExchangeDeclare) ProtoMessage()    {}
func (*ExchangeDeclare) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{18}
}
func (m *ExchangeDeclare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeDeclare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeDeclare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeDeclare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeDeclare.Merge(m, src)
}
func (m *ExchangeDeclare) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeDeclare) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeDeclare.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeDeclare proto.InternalMessageInfo

type ExchangeDeclareOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeDeclareOk) Reset()         { *m = ExchangeDeclareOk{} }
func (m *ExchangeDeclareOk) String() string { return proto.CompactTextString(m) }
func (*ExchangeDeclareOk) ProtoMessage()    {}
func (*ExchangeDeclareOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{19}
}
func (m *ExchangeDeclareOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeDeclareOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeDeclareOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeDeclareOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeDeclareOk.Merge(m, src)
}
func (m *ExchangeDeclareOk) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeDeclareOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeDeclareOk.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeDeclareOk proto.InternalMessageInfo

type ExchangeDelete struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Exchange             string   `protobuf:"bytes,2,opt,name=exchange" json:"exchange"`
	IfUnused             bool     `protobuf:"varint,3,opt,name=if_unused,json=ifUnused" json:"if_unused"`
	NoWait               bool     `protobuf:"varint,4,opt,name=no_wait,json=noWait" json:"no_wait"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeDelete) Reset()         { *m = ExchangeDelete{} }
func (m *ExchangeDelete) String() string { return proto.CompactTextString(m) }
func (*ExchangeDelete) ProtoMessage()    {}
func (*ExchangeDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{20}
}
func (m *ExchangeDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeDelete.Merge(m, src)
}
func (m *ExchangeDelete) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeDelete.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeDelete proto.InternalMessageInfo

type ExchangeDeleteOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeDeleteOk) Reset()         { *m = ExchangeDeleteOk{} }
func (m *ExchangeDeleteOk) String() string { return proto.CompactTextString(m) }
func (*ExchangeDeleteOk) ProtoMessage()    {}
func (*ExchangeDeleteOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{21}
}
func (m *ExchangeDeleteOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeDeleteOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeDeleteOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeDeleteOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeDeleteOk.Merge(m, src)
}
func (m *ExchangeDeleteOk) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeDeleteOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeDeleteOk.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeDeleteOk proto.InternalMessageInfo

type ExchangeBind struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Destination          string   `protobuf:"bytes,2,opt,name=destination" json:"destination"`
	Source               string   `protobuf:"bytes,3,opt,name=source" json:"source"`
	RoutingKey           string   `protobuf:"bytes,4,opt,name=routing_key,json=routingKey" json:"routing_key"`
	NoWait               bool     `protobuf:"varint,5,opt,name=no_wait,json=noWait" json:"no_wait"`
	Arguments            *Table   `protobuf:"bytes,6,opt,name=arguments" json:"arguments,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeBind) Reset()         { *m = ExchangeBind{} }
func (m *ExchangeBind) String() string { return proto.CompactTextString(m) }
func (*ExchangeBind) ProtoMessage()    {}
func (*ExchangeBind) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{22}
}
func (m *ExchangeBind) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeBind) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeBind.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeBind) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeBind.Merge(m, src)
}
func (m *ExchangeBind) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeBind) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeBind.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeBind proto.InternalMessageInfo

type ExchangeBindOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeBindOk) Reset()         { *m = ExchangeBindOk{} }
func (m *ExchangeBindOk) String() string { return proto.CompactTextString(m) }
func (*ExchangeBindOk) ProtoMessage()    {}
func (*ExchangeBindOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{23}
}
func (m *ExchangeBindOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeBindOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeBindOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeBindOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeBindOk.Merge(m, src)
}
func (m *ExchangeBindOk) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeBindOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeBindOk.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeBindOk proto.InternalMessageInfo

type ExchangeUnbind struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Destination          string   `protobuf:"bytes,2,opt,name=destination" json:"destination"`
	Source               string   `protobuf:"bytes,3,opt,name=source" json:"source"`
	RoutingKey           string   `protobuf:"bytes,4,opt,name=routing_key,json=routingKey" json:"routing_key"`
	NoWait               bool     `protobuf:"varint,5,opt,name=no_wait,json=noWait" json:"no_wait"`
	Arguments            *Table   `protobuf:"bytes,6,opt,name=arguments" json:"arguments,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeUnbind) Reset()         { *m = ExchangeUnbind{} }
func (m *ExchangeUnbind) String() string { return proto.CompactTextString(m) }
func (*ExchangeUnbind) ProtoMessage()    {}
func (*ExchangeUnbind) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{24}
}
func (m *ExchangeUnbind) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeUnbind) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeUnbind.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeUnbind) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeUnbind.Merge(m, src)
}
func (m *ExchangeUnbind) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeUnbind) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeUnbind.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeUnbind proto.InternalMessageInfo

type ExchangeUnbindOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeUnbindOk) Reset()         { *m = ExchangeUnbindOk{} }
func (m *ExchangeUnbindOk) String() string { return proto.CompactTextString(m) }
func (*ExchangeUnbindOk) ProtoMessage()    {}
func (*ExchangeUnbindOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{25}
}
func (m *ExchangeUnbindOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeUnbindOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeUnbindOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeUnbindOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeUnbindOk.Merge(m, src)
}
func (m *ExchangeUnbindOk) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeUnbindOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeUnbindOk.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeUnbindOk proto.InternalMessageInfo

type QueueDeclare struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Queue                string   `protobuf:"bytes,2,opt,name=queue" json:"queue"`
	Passive              bool     `protobuf:"varint,3,opt,name=passive" json:"passive"`
	Durable              bool     `protobuf:"varint,4,opt,name=durable" json:"durable"`
	Exclusive            bool     `protobuf:"varint,5,opt,name=exclusive" json:"exclusive"`
	AutoDelete           bool     `protobuf:"varint,6,opt,name=auto_delete,json=autoDelete" json:"auto_delete"`
	NoWait               bool     `protobuf:"varint,7,opt,name=no_wait,json=noWait" json:"no_wait"`
	Arguments            *Table   `protobuf:"bytes,8,opt,name=arguments" json:"arguments,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueDeclare) Reset()         { *m = QueueDeclare{} }
func (m *QueueDeclare) String() string { return proto.CompactTextString(m) }
func (*QueueDeclare) ProtoMessage()    {}
func (*QueueDeclare) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{26}
}
func (m *QueueDeclare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueDeclare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueDeclare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueDeclare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueDeclare.Merge(m, src)
}
func (m *QueueDeclare) XXX_Size() int {
	return m.Size()
}
func (m *QueueDeclare) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueDeclare.DiscardUnknown(m)
}

var xxx_messageInfo_QueueDeclare proto.InternalMessageInfo

type QueueDeclareOk struct {
	Queue                string   `protobuf:"bytes,1,opt,name=queue" json:"queue"`
	MessageCount         uint32   `protobuf:"varint,2,opt,name=message_count,json=messageCount" json:"message_count"`
	ConsumerCount        uint32   `protobuf:"varint,3,opt,name=consumer_count,json=consumerCount" json:"consumer_count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueDeclareOk) Reset()         { *m = QueueDeclareOk{} }
func (m *QueueDeclareOk) String() string { return proto.CompactTextString(m) }
func (*QueueDeclareOk) ProtoMessage()    {}
func (*QueueDeclareOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{27}
}
func (m *QueueDeclareOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueDeclareOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueDeclareOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueDeclareOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueDeclareOk.Merge(m, src)
}
func (m *QueueDeclareOk) XXX_Size() int {
	return m.Size()
}
func (m *QueueDeclareOk) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueDeclareOk.DiscardUnknown(m)
}

var xxx_messageInfo_QueueDeclareOk proto.InternalMessageInfo

type QueueBind struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Queue                string   `protobuf:"bytes,2,opt,name=queue" json:"queue"`
	Exchange             string   `protobuf:"bytes,3,opt,name=exchange" json:"exchange"`
	RoutingKey           string   `protobuf:"bytes,4,opt,name=routing_key,json=routingKey" json:"routing_key"`
	NoWait               bool     `protobuf:"varint,5,opt,name=no_wait,json=noWait" json:"no_wait"`
	Arguments            *Table   `protobuf:"bytes,6,opt,name=arguments" json:"arguments,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueBind) Reset()         { *m = QueueBind{} }
func (m *QueueBind) String() string { return proto.CompactTextString(m) }
func (*QueueBind) ProtoMessage()    {}
func (*QueueBind) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{28}
}
func (m *QueueBind) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueBind) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueBind.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueBind) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueBind.Merge(m, src)
}
func (m *QueueBind) XXX_Size() int {
	return m.Size()
}
func (m *QueueBind) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueBind.DiscardUnknown(m)
}

var xxx_messageInfo_QueueBind proto.InternalMessageInfo

type QueueBindOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueBindOk) Reset()         { *m = QueueBindOk{} }
func (m *QueueBindOk) String() string { return proto.CompactTextString(m) }
func (*QueueBindOk) ProtoMessage()    {}
func (*QueueBindOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{29}
}
func (m *QueueBindOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueBindOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueBindOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueBindOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueBindOk.Merge(m, src)
}
func (m *QueueBindOk) XXX_Size() int {
	return m.Size()
}
func (m *QueueBindOk) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueBindOk.DiscardUnknown(m)
}

var xxx_messageInfo_QueueBindOk proto.InternalMessageInfo

type QueueUnbind struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Queue                string   `protobuf:"bytes,2,opt,name=queue" json:"queue"`
	Exchange             string   `protobuf:"bytes,3,opt,name=exchange" json:"exchange"`
	RoutingKey           string   `protobuf:"bytes,4,opt,name=routing_key,json=routingKey" json:"routing_key"`
	Arguments            *Table   `protobuf:"bytes,5,opt,name=arguments" json:"arguments,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueUnbind) Reset()         { *m = QueueUnbind{} }
func (m *QueueUnbind) String() string { return proto.CompactTextString(m) }
func (*QueueUnbind) ProtoMessage()    {}
func (*QueueUnbind) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{30}
}
func (m *QueueUnbind) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueUnbind) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueUnbind.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueUnbind) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueUnbind.Merge(m, src)
}
func (m *QueueUnbind) XXX_Size() int {
	return m.Size()
}
func (m *QueueUnbind) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueUnbind.DiscardUnknown(m)
}

var xxx_messageInfo_QueueUnbind proto.InternalMessageInfo

type QueueUnbindOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueUnbindOk) Reset()         { *m = QueueUnbindOk{} }
func (m *QueueUnbindOk) String() string { return proto.CompactTextString(m) }
func (*QueueUnbindOk) ProtoMessage()    {}
func (*QueueUnbindOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{31}
}
func (m *QueueUnbindOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueUnbindOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueUnbindOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueUnbindOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueUnbindOk.Merge(m, src)
}
func (m *QueueUnbindOk) XXX_Size() int {
	return m.Size()
}
func (m *QueueUnbindOk) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueUnbindOk.DiscardUnknown(m)
}

var xxx_messageInfo_QueueUnbindOk proto.InternalMessageInfo

type QueuePurge struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Queue                string   `protobuf:"bytes,2,opt,name=queue" json:"queue"`
	NoWait               bool     `protobuf:"varint,3,opt,name=no_wait,json=noWait" json:"no_wait"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueuePurge) Reset()         { *m = QueuePurge{} }
func (m *QueuePurge) String() string { return proto.CompactTextString(m) }
func (*QueuePurge) ProtoMessage()    {}
func (*QueuePurge) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{32}
}
func (m *QueuePurge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuePurge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuePurge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuePurge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuePurge.Merge(m, src)
}
func (m *QueuePurge) XXX_Size() int {
	return m.Size()
}
func (m *QueuePurge) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuePurge.DiscardUnknown(m)
}

var xxx_messageInfo_QueuePurge proto.InternalMessageInfo

type QueuePurgeOk struct {
	MessageCount         uint32   `protobuf:"varint,1,opt,name=message_count,json=messageCount" json:"message_count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueuePurgeOk) Reset()         { *m = QueuePurgeOk{} }
func (m *QueuePurgeOk) String() string { return proto.CompactTextString(m) }
func (*QueuePurgeOk) ProtoMessage()    {}
func (*QueuePurgeOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{33}
}
func (m *QueuePurgeOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueuePurgeOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueuePurgeOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueuePurgeOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueuePurgeOk.Merge(m, src)
}
func (m *QueuePurgeOk) XXX_Size() int {
	return m.Size()
}
func (m *QueuePurgeOk) XXX_DiscardUnknown() {
	xxx_messageInfo_QueuePurgeOk.DiscardUnknown(m)
}

var xxx_messageInfo_QueuePurgeOk proto.InternalMessageInfo

type QueueDelete struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Queue                string   `protobuf:"bytes,2,opt,name=queue" json:"queue"`
	IfUnused             bool     `protobuf:"varint,3,opt,name=if_unused,json=ifUnused" json:"if_unused"`
	IfEmpty              bool     `protobuf:"varint,4,opt,name=if_empty,json=ifEmpty" json:"if_empty"`
	NoWait               bool     `protobuf:"varint,5,opt,name=no_wait,json=noWait" json:"no_wait"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueDelete) Reset()         { *m = QueueDelete{} }
func (m *QueueDelete) String() string { return proto.CompactTextString(m) }
func (*QueueDelete) ProtoMessage()    {}
func (*QueueDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{34}
}
func (m *QueueDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueDelete.Merge(m, src)
}
func (m *QueueDelete) XXX_Size() int {
	return m.Size()
}
func (m *QueueDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueDelete.DiscardUnknown(m)
}

var xxx_messageInfo_QueueDelete proto.InternalMessageInfo

type QueueDeleteOk struct {
	MessageCount         uint32   `protobuf:"varint,1,opt,name=message_count,json=messageCount" json:"message_count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueDeleteOk) Reset()         { *m = QueueDeleteOk{} }
func (m *QueueDeleteOk) String() string { return proto.CompactTextString(m) }
func (*QueueDeleteOk) ProtoMessage()    {}
func (*QueueDeleteOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{35}
}
func (m *QueueDeleteOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueDeleteOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueDeleteOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueDeleteOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueDeleteOk.Merge(m, src)
}
func (m *QueueDeleteOk) XXX_Size() int {
	return m.Size()
}
func (m *QueueDeleteOk) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueDeleteOk.DiscardUnknown(m)
}

var xxx_messageInfo_QueueDeleteOk proto.InternalMessageInfo

type BasicContentHeaderProperties struct {
	ContentType          *string  `protobuf:"bytes,1,opt,name=content_type,json=contentType" json:"content_type,omitempty"`
	ContentEncoding      *string  `protobuf:"bytes,2,opt,name=content_encoding,json=contentEncoding" json:"content_encoding,omitempty"`
	Headers              *Table   `protobuf:"bytes,3,opt,name=headers" json:"headers,omitempty"`
	DeliveryMode         *byte    `protobuf:"varint,4,opt,name=delivery_mode,json=deliveryMode,casttype=byte" json:"delivery_mode,omitempty"`
	Priority             *byte    `protobuf:"varint,5,opt,name=priority,casttype=byte" json:"priority,omitempty"`
	CorrelationId        *string  `protobuf:"bytes,6,opt,name=correlation_id,json=correlationId" json:"correlation_id,omitempty"`
	ReplyTo              *string  `protobuf:"bytes,7,opt,name=reply_to,json=replyTo" json:"reply_to,omitempty"`
	Expiration           *string  `protobuf:"bytes,8,opt,name=expiration" json:"expiration,omitempty"`
	MessageId            *string  `protobuf:"bytes,9,opt,name=message_id,json=messageId" json:"message_id,omitempty"`
	Timestamp            *uint64  `protobuf:"varint,10,opt,name=timestamp" json:"timestamp,omitempty"`
	Type                 *string  `protobuf:"bytes,11,opt,name=type" json:"type,omitempty"`
	UserId               *string  `protobuf:"bytes,12,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	AppId                *string  `protobuf:"bytes,13,opt,name=app_id,json=appId" json:"app_id,omitempty"`
	Reserved             *string  `protobuf:"bytes,14,opt,name=reserved" json:"reserved,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicContentHeaderProperties) Reset()         { *m = BasicContentHeaderProperties{} }
func (m *BasicContentHeaderProperties) String() string { return proto.CompactTextString(m) }
func (*BasicContentHeaderProperties) ProtoMessage()    {}
func (*BasicContentHeaderProperties) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{36}
}
func (m *BasicContentHeaderProperties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicContentHeaderProperties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicContentHeaderProperties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicContentHeaderProperties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicContentHeaderProperties.Merge(m, src)
}
func (m *BasicContentHeaderProperties) XXX_Size() int {
	return m.Size()
}
func (m *BasicContentHeaderProperties) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicContentHeaderProperties.DiscardUnknown(m)
}

var xxx_messageInfo_BasicContentHeaderProperties proto.InternalMessageInfo

func (m *BasicContentHeaderProperties) GetContentType() string {
	if m != nil && m.ContentType != nil {
		return *m.ContentType
	}
	return ""
}

func (m *BasicContentHeaderProperties) GetContentEncoding() string {
	if m != nil && m.ContentEncoding != nil {
		return *m.ContentEncoding
	}
	return ""
}

func (m *BasicContentHeaderProperties) GetHeaders() *Table {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *BasicContentHeaderProperties) GetDeliveryMode() byte {
	if m != nil && m.DeliveryMode != nil {
		return *m.DeliveryMode
	}
	return 0
}

func (m *BasicContentHeaderProperties) GetPriority() byte {
	if m != nil && m.Priority != nil {
		return *m.Priority
	}
	return 0
}

func (m *BasicContentHeaderProperties) GetCorrelationId() string {
	if m != nil && m.CorrelationId != nil {
		return *m.CorrelationId
	}
	return ""
}

func (m *BasicContentHeaderProperties) GetReplyTo() string {
	if m != nil && m.ReplyTo != nil {
		return *m.ReplyTo
	}
	return ""
}

func (m *BasicContentHeaderProperties) GetExpiration() string {
	if m != nil && m.Expiration != nil {
		return *m.Expiration
	}
	return ""
}

func (m *BasicContentHeaderProperties) GetMessageId() string {
	if m != nil && m.MessageId != nil {
		return *m.MessageId
	}
	return ""
}

func (m *BasicContentHeaderProperties) GetTimestamp() uint64 {
	if m != nil && m.Timestamp != nil {
		return *m.Timestamp
	}
	return 0
}

func (m *BasicContentHeaderProperties) GetType() string {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ""
}

func (m *BasicContentHeaderProperties) GetUserId() string {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return ""
}

func (m *BasicContentHeaderProperties) GetAppId() string {
	if m != nil && m.AppId != nil {
		return *m.AppId
	}
	return ""
}

func (m *BasicContentHeaderProperties) GetReserved() string {
	if m != nil && m.Reserved != nil {
		return *m.Reserved
	}
	return ""
}

type BasicQos struct {
	PrefetchSize         uint32   `protobuf:"varint,1,opt,name=prefetch_size,json=prefetchSize" json:"prefetch_size"`
	PrefetchCount        uint16   `protobuf:"varint,2,opt,name=prefetch_count,json=prefetchCount,casttype=uint16" json:"prefetch_count"`
	Global               bool     `protobuf:"varint,3,opt,name=global" json:"global"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicQos) Reset()         { *m = BasicQos{} }
func (m *BasicQos) String() string { return proto.CompactTextString(m) }
func (*BasicQos) ProtoMessage()    {}
func (*BasicQos) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{37}
}
func (m *BasicQos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicQos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicQos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicQos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicQos.Merge(m, src)
}
func (m *BasicQos) XXX_Size() int {
	return m.Size()
}
func (m *BasicQos) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicQos.DiscardUnknown(m)
}

var xxx_messageInfo_BasicQos proto.InternalMessageInfo

type BasicQosOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicQosOk) Reset()         { *m = BasicQosOk{} }
func (m *BasicQosOk) String() string { return proto.CompactTextString(m) }
func (*BasicQosOk) ProtoMessage()    {}
func (*BasicQosOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{38}
}
func (m *BasicQosOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicQosOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicQosOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicQosOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicQosOk.Merge(m, src)
}
func (m *BasicQosOk) XXX_Size() int {
	return m.Size()
}
func (m *BasicQosOk) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicQosOk.DiscardUnknown(m)
}

var xxx_messageInfo_BasicQosOk proto.InternalMessageInfo

type BasicConsume struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Queue                string   `protobuf:"bytes,2,opt,name=queue" json:"queue"`
	ConsumerTag          string   `protobuf:"bytes,3,opt,name=consumer_tag,json=consumerTag" json:"consumer_tag"`
	NoLocal              bool     `protobuf:"varint,4,opt,name=no_local,json=noLocal" json:"no_local"`
	NoAck                bool     `protobuf:"varint,5,opt,name=no_ack,json=noAck" json:"no_ack"`
	Exclusive            bool     `protobuf:"varint,6,opt,name=exclusive" json:"exclusive"`
	NoWait               bool     `protobuf:"varint,7,opt,name=no_wait,json=noWait" json:"no_wait"`
	Arguments            *Table   `protobuf:"bytes,8,opt,name=arguments" json:"arguments,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicConsume) Reset()         { *m = BasicConsume{} }
func (m *BasicConsume) String() string { return proto.CompactTextString(m) }
func (*BasicConsume) ProtoMessage()    {}
func (*BasicConsume) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{39}
}
func (m *BasicConsume) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicConsume) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicConsume.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicConsume) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicConsume.Merge(m, src)
}
func (m *BasicConsume) XXX_Size() int {
	return m.Size()
}
func (m *BasicConsume) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicConsume.DiscardUnknown(m)
}

var xxx_messageInfo_BasicConsume proto.InternalMessageInfo

type BasicConsumeOk struct {
	ConsumerTag          string   `protobuf:"bytes,1,opt,name=consumer_tag,json=consumerTag" json:"consumer_tag"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicConsumeOk) Reset()         { *m = BasicConsumeOk{} }
func (m *BasicConsumeOk) String() string { return proto.CompactTextString(m) }
func (*BasicConsumeOk) ProtoMessage()    {}
func (*BasicConsumeOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{40}
}
func (m *BasicConsumeOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicConsumeOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicConsumeOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicConsumeOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicConsumeOk.Merge(m, src)
}
func (m *BasicConsumeOk) XXX_Size() int {
	return m.Size()
}
func (m *BasicConsumeOk) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicConsumeOk.DiscardUnknown(m)
}

var xxx_messageInfo_BasicConsumeOk proto.InternalMessageInfo

type BasicCancel struct {
	ConsumerTag          string   `protobuf:"bytes,1,opt,name=consumer_tag,json=consumerTag" json:"consumer_tag"`
	NoWait               bool     `protobuf:"varint,2,opt,name=no_wait,json=noWait" json:"no_wait"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicCancel) Reset()         { *m = BasicCancel{} }
func (m *BasicCancel) String() string { return proto.CompactTextString(m) }
func (*BasicCancel) ProtoMessage()    {}
func (*BasicCancel) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{41}
}
func (m *BasicCancel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicCancel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicCancel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicCancel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicCancel.Merge(m, src)
}
func (m *BasicCancel) XXX_Size() int {
	return m.Size()
}
func (m *BasicCancel) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicCancel.DiscardUnknown(m)
}

var xxx_messageInfo_BasicCancel proto.InternalMessageInfo

type BasicCancelOk struct {
	ConsumerTag          string   `protobuf:"bytes,1,opt,name=consumer_tag,json=consumerTag" json:"consumer_tag"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicCancelOk) Reset()         { *m = BasicCancelOk{} }
func (m *BasicCancelOk) String() string { return proto.CompactTextString(m) }
func (*BasicCancelOk) ProtoMessage()    {}
func (*BasicCancelOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{42}
}
func (m *BasicCancelOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicCancelOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicCancelOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicCancelOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicCancelOk.Merge(m, src)
}
func (m *BasicCancelOk) XXX_Size() int {
	return m.Size()
}
func (m *BasicCancelOk) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicCancelOk.DiscardUnknown(m)
}

var xxx_messageInfo_BasicCancelOk proto.InternalMessageInfo

type BasicPublish struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Exchange             string   `protobuf:"bytes,2,opt,name=exchange" json:"exchange"`
	RoutingKey           string   `protobuf:"bytes,3,opt,name=routing_key,json=routingKey" json:"routing_key"`
	Mandatory            bool     `protobuf:"varint,4,opt,name=mandatory" json:"mandatory"`
	Immediate            bool     `protobuf:"varint,5,opt,name=immediate" json:"immediate"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicPublish) Reset()         { *m = BasicPublish{} }
func (m *BasicPublish) String() string { return proto.CompactTextString(m) }
func (*BasicPublish) ProtoMessage()    {}
func (*BasicPublish) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{43}
}
func (m *BasicPublish) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicPublish) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicPublish.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicPublish) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicPublish.Merge(m, src)
}
func (m *BasicPublish) XXX_Size() int {
	return m.Size()
}
func (m *BasicPublish) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicPublish.DiscardUnknown(m)
}

var xxx_messageInfo_BasicPublish proto.InternalMessageInfo

type BasicReturn struct {
	ReplyCode            uint16   `protobuf:"varint,1,opt,name=reply_code,json=replyCode,casttype=uint16" json:"reply_code"`
	ReplyText            string   `protobuf:"bytes,2,opt,name=reply_text,json=replyText" json:"reply_text"`
	Exchange             string   `protobuf:"bytes,3,opt,name=exchange" json:"exchange"`
	RoutingKey           string   `protobuf:"bytes,4,opt,name=routing_key,json=routingKey" json:"routing_key"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicReturn) Reset()         { *m = BasicReturn{} }
func (m *BasicReturn) String() string { return proto.CompactTextString(m) }
func (*BasicReturn) ProtoMessage()    {}
func (*BasicReturn) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{44}
}
func (m *BasicReturn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicReturn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicReturn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicReturn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicReturn.Merge(m, src)
}
func (m *BasicReturn) XXX_Size() int {
	return m.Size()
}
func (m *BasicReturn) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicReturn.DiscardUnknown(m)
}

var xxx_messageInfo_BasicReturn proto.InternalMessageInfo

type BasicDeliver struct {
	ConsumerTag          string   `protobuf:"bytes,1,opt,name=consumer_tag,json=consumerTag" json:"consumer_tag"`
	DeliveryTag          uint64   `protobuf:"varint,2,opt,name=delivery_tag,json=deliveryTag" json:"delivery_tag"`
	Redelivered          bool     `protobuf:"varint,3,opt,name=redelivered" json:"redelivered"`
	Exchange             string   `protobuf:"bytes,4,opt,name=exchange" json:"exchange"`
	RoutingKey           string   `protobuf:"bytes,5,opt,name=routing_key,json=routingKey" json:"routing_key"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicDeliver) Reset()         { *m = BasicDeliver{} }
func (m *BasicDeliver) String() string { return proto.CompactTextString(m) }
func (*BasicDeliver) ProtoMessage()    {}
func (*BasicDeliver) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{45}
}
func (m *BasicDeliver) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicDeliver) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicDeliver.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicDeliver) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicDeliver.Merge(m, src)
}
func (m *BasicDeliver) XXX_Size() int {
	return m.Size()
}
func (m *BasicDeliver) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicDeliver.DiscardUnknown(m)
}

var xxx_messageInfo_BasicDeliver proto.InternalMessageInfo

type BasicGet struct {
	Reserved1            uint16   `protobuf:"varint,1,opt,name=reserved1,casttype=uint16" json:"reserved1"`
	Queue                string   `protobuf:"bytes,2,opt,name=queue" json:"queue"`
	NoAck                bool     `protobuf:"varint,3,opt,name=no_ack,json=noAck" json:"no_ack"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicGet) Reset()         { *m = BasicGet{} }
func (m *BasicGet) String() string { return proto.CompactTextString(m) }
func (*BasicGet) ProtoMessage()    {}
func (*BasicGet) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{46}
}
func (m *BasicGet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicGet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicGet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicGet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicGet.Merge(m, src)
}
func (m *BasicGet) XXX_Size() int {
	return m.Size()
}
func (m *BasicGet) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicGet.DiscardUnknown(m)
}

var xxx_messageInfo_BasicGet proto.InternalMessageInfo

type BasicGetOk struct {
	DeliveryTag          uint64   `protobuf:"varint,1,opt,name=delivery_tag,json=deliveryTag" json:"delivery_tag"`
	Redelivered          bool     `protobuf:"varint,2,opt,name=redelivered" json:"redelivered"`
	Exchange             string   `protobuf:"bytes,3,opt,name=exchange" json:"exchange"`
	RoutingKey           string   `protobuf:"bytes,4,opt,name=routing_key,json=routingKey" json:"routing_key"`
	MessageCount         uint32   `protobuf:"varint,5,opt,name=message_count,json=messageCount" json:"message_count"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicGetOk) Reset()         { *m = BasicGetOk{} }
func (m *BasicGetOk) String() string { return proto.CompactTextString(m) }
func (*BasicGetOk) ProtoMessage()    {}
func (*BasicGetOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{47}
}
func (m *BasicGetOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicGetOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicGetOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicGetOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicGetOk.Merge(m, src)
}
func (m *BasicGetOk) XXX_Size() int {
	return m.Size()
}
func (m *BasicGetOk) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicGetOk.DiscardUnknown(m)
}

var xxx_messageInfo_BasicGetOk proto.InternalMessageInfo

type BasicGetEmpty struct {
	Reserved1            string   `protobuf:"bytes,1,opt,name=reserved1" json:"reserved1"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicGetEmpty) Reset()         { *m = BasicGetEmpty{} }
func (m *BasicGetEmpty) String() string { return proto.CompactTextString(m) }
func (*BasicGetEmpty) ProtoMessage()    {}
func (*BasicGetEmpty) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{48}
}
func (m *BasicGetEmpty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicGetEmpty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicGetEmpty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicGetEmpty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicGetEmpty.Merge(m, src)
}
func (m *BasicGetEmpty) XXX_Size() int {
	return m.Size()
}
func (m *BasicGetEmpty) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicGetEmpty.DiscardUnknown(m)
}

var xxx_messageInfo_BasicGetEmpty proto.InternalMessageInfo

type BasicAck struct {
	DeliveryTag          uint64   `protobuf:"varint,1,opt,name=delivery_tag,json=deliveryTag" json:"delivery_tag"`
	Multiple             bool     `protobuf:"varint,2,opt,name=multiple" json:"multiple"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicAck) Reset()         { *m = BasicAck{} }
func (m *BasicAck) String() string { return proto.CompactTextString(m) }
func (*BasicAck) ProtoMessage()    {}
func (*BasicAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{49}
}
func (m *BasicAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicAck.Merge(m, src)
}
func (m *BasicAck) XXX_Size() int {
	return m.Size()
}
func (m *BasicAck) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicAck.DiscardUnknown(m)
}

var xxx_messageInfo_BasicAck proto.InternalMessageInfo

type BasicReject struct {
	DeliveryTag          uint64   `protobuf:"varint,1,opt,name=delivery_tag,json=deliveryTag" json:"delivery_tag"`
	Requeue              bool     `protobuf:"varint,2,opt,name=requeue" json:"requeue"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicReject) Reset()         { *m = BasicReject{} }
func (m *BasicReject) String() string { return proto.CompactTextString(m) }
func (*BasicReject) ProtoMessage()    {}
func (*BasicReject) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{50}
}
func (m *BasicReject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicReject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicReject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicReject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicReject.Merge(m, src)
}
func (m *BasicReject) XXX_Size() int {
	return m.Size()
}
func (m *BasicReject) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicReject.DiscardUnknown(m)
}

var xxx_messageInfo_BasicReject proto.InternalMessageInfo

type BasicRecoverAsync struct {
	Requeue              bool     `protobuf:"varint,1,opt,name=requeue" json:"requeue"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicRecoverAsync) Reset()         { *m = BasicRecoverAsync{} }
func (m *BasicRecoverAsync) String() string { return proto.CompactTextString(m) }
func (*BasicRecoverAsync) ProtoMessage()    {}
func (*BasicRecoverAsync) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{51}
}
func (m *BasicRecoverAsync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicRecoverAsync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicRecoverAsync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicRecoverAsync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicRecoverAsync.Merge(m, src)
}
func (m *BasicRecoverAsync) XXX_Size() int {
	return m.Size()
}
func (m *BasicRecoverAsync) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicRecoverAsync.DiscardUnknown(m)
}

var xxx_messageInfo_BasicRecoverAsync proto.InternalMessageInfo

type BasicRecover struct {
	Requeue              bool     `protobuf:"varint,1,opt,name=requeue" json:"requeue"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicRecover) Reset()         { *m = BasicRecover{} }
func (m *BasicRecover) String() string { return proto.CompactTextString(m) }
func (*BasicRecover) ProtoMessage()    {}
func (*BasicRecover) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{52}
}
func (m *BasicRecover) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicRecover) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicRecover.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicRecover) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicRecover.Merge(m, src)
}
func (m *BasicRecover) XXX_Size() int {
	return m.Size()
}
func (m *BasicRecover) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicRecover.DiscardUnknown(m)
}

var xxx_messageInfo_BasicRecover proto.InternalMessageInfo

type BasicRecoverOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicRecoverOk) Reset()         { *m = BasicRecoverOk{} }
func (m *BasicRecoverOk) String() string { return proto.CompactTextString(m) }
func (*BasicRecoverOk) ProtoMessage()    {}
func (*BasicRecoverOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{53}
}
func (m *BasicRecoverOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicRecoverOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicRecoverOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicRecoverOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicRecoverOk.Merge(m, src)
}
func (m *BasicRecoverOk) XXX_Size() int {
	return m.Size()
}
func (m *BasicRecoverOk) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicRecoverOk.DiscardUnknown(m)
}

var xxx_messageInfo_BasicRecoverOk proto.InternalMessageInfo

type BasicNack struct {
	DeliveryTag          uint64   `protobuf:"varint,1,opt,name=delivery_tag,json=deliveryTag" json:"delivery_tag"`
	Multiple             bool     `protobuf:"varint,2,opt,name=multiple" json:"multiple"`
	Requeue              bool     `protobuf:"varint,3,opt,name=requeue" json:"requeue"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BasicNack) Reset()         { *m = BasicNack{} }
func (m *BasicNack) String() string { return proto.CompactTextString(m) }
func (*BasicNack) ProtoMessage()    {}
func (*BasicNack) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{54}
}
func (m *BasicNack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicNack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicNack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicNack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicNack.Merge(m, src)
}
func (m *BasicNack) XXX_Size() int {
	return m.Size()
}
func (m *BasicNack) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicNack.DiscardUnknown(m)
}

var xxx_messageInfo_BasicNack proto.InternalMessageInfo

type TxSelect struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxSelect) Reset()         { *m = TxSelect{} }
func (m *TxSelect) String() string { return proto.CompactTextString(m) }
func (*TxSelect) ProtoMessage()    {}
func (*TxSelect) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{55}
}
func (m *TxSelect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxSelect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxSelect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxSelect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxSelect.Merge(m, src)
}
func (m *TxSelect) XXX_Size() int {
	return m.Size()
}
func (m *TxSelect) XXX_DiscardUnknown() {
	xxx_messageInfo_TxSelect.DiscardUnknown(m)
}

var xxx_messageInfo_TxSelect proto.InternalMessageInfo

type TxSelectOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxSelectOk) Reset()         { *m = TxSelectOk{} }
func (m *TxSelectOk) String() string { return proto.CompactTextString(m) }
func (*TxSelectOk) ProtoMessage()    {}
func (*TxSelectOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{56}
}
func (m *TxSelectOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxSelectOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxSelectOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxSelectOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxSelectOk.Merge(m, src)
}
func (m *TxSelectOk) XXX_Size() int {
	return m.Size()
}
func (m *TxSelectOk) XXX_DiscardUnknown() {
	xxx_messageInfo_TxSelectOk.DiscardUnknown(m)
}

var xxx_messageInfo_TxSelectOk proto.InternalMessageInfo

type TxCommit struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxCommit) Reset()         { *m = TxCommit{} }
func (m *TxCommit) String() string { return proto.CompactTextString(m) }
func (*TxCommit) ProtoMessage()    {}
func (*TxCommit) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{57}
}
func (m *TxCommit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxCommit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxCommit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxCommit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxCommit.Merge(m, src)
}
func (m *TxCommit) XXX_Size() int {
	return m.Size()
}
func (m *TxCommit) XXX_DiscardUnknown() {
	xxx_messageInfo_TxCommit.DiscardUnknown(m)
}

var xxx_messageInfo_TxCommit proto.InternalMessageInfo

type TxCommitOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxCommitOk) Reset()         { *m = TxCommitOk{} }
func (m *TxCommitOk) String() string { return proto.CompactTextString(m) }
func (*TxCommitOk) ProtoMessage()    {}
func (*TxCommitOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{58}
}
func (m *TxCommitOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxCommitOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxCommitOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxCommitOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxCommitOk.Merge(m, src)
}
func (m *TxCommitOk) XXX_Size() int {
	return m.Size()
}
func (m *TxCommitOk) XXX_DiscardUnknown() {
	xxx_messageInfo_TxCommitOk.DiscardUnknown(m)
}

var xxx_messageInfo_TxCommitOk proto.InternalMessageInfo

type TxRollback struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxRollback) Reset()         { *m = TxRollback{} }
func (m *TxRollback) String() string { return proto.CompactTextString(m) }
func (*TxRollback) ProtoMessage()    {}
func (*TxRollback) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{59}
}
func (m *TxRollback) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRollback) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRollback.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxRollback) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRollback.Merge(m, src)
}
func (m *TxRollback) XXX_Size() int {
	return m.Size()
}
func (m *TxRollback) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRollback.DiscardUnknown(m)
}

var xxx_messageInfo_TxRollback proto.InternalMessageInfo

type TxRollbackOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxRollbackOk) Reset()         { *m = TxRollbackOk{} }
func (m *TxRollbackOk) String() string { return proto.CompactTextString(m) }
func (*TxRollbackOk) ProtoMessage()    {}
func (*TxRollbackOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{60}
}
func (m *TxRollbackOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRollbackOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRollbackOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxRollbackOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRollbackOk.Merge(m, src)
}
func (m *TxRollbackOk) XXX_Size() int {
	return m.Size()
}
func (m *TxRollbackOk) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRollbackOk.DiscardUnknown(m)
}

var xxx_messageInfo_TxRollbackOk proto.InternalMessageInfo

type ConfirmSelect struct {
	Nowait               bool     `protobuf:"varint,1,opt,name=nowait" json:"nowait"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfirmSelect) Reset()         { *m = ConfirmSelect{} }
func (m *ConfirmSelect) String() string { return proto.CompactTextString(m) }
func (*ConfirmSelect) ProtoMessage()    {}
func (*ConfirmSelect) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{61}
}
func (m *ConfirmSelect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfirmSelect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfirmSelect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfirmSelect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfirmSelect.Merge(m, src)
}
func (m *ConfirmSelect) XXX_Size() int {
	return m.Size()
}
func (m *ConfirmSelect) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfirmSelect.DiscardUnknown(m)
}

var xxx_messageInfo_ConfirmSelect proto.InternalMessageInfo

type ConfirmSelectOk struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfirmSelectOk) Reset()         { *m = ConfirmSelectOk{} }
func (m *ConfirmSelectOk) String() string { return proto.CompactTextString(m) }
func (*ConfirmSelectOk) ProtoMessage()    {}
func (*ConfirmSelectOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_1dd71637af170cde, []int{62}
}
func (m *ConfirmSelectOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfirmSelectOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfirmSelectOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfirmSelectOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfirmSelectOk.Merge(m, src)
}
func (m *ConfirmSelectOk) XXX_Size() int {
	return m.Size()
}
func (m *ConfirmSelectOk) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfirmSelectOk.DiscardUnknown(m)
}

var xxx_messageInfo_ConfirmSelectOk proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ConnectionStart)(nil), "amqp.ConnectionStart")
	proto.RegisterType((*ConnectionStartOk)(nil), "amqp.ConnectionStartOk")
	proto.RegisterType((*ConnectionSecure)(nil), "amqp.ConnectionSecure")
	proto.RegisterType((*ConnectionSecureOk)(nil), "amqp.ConnectionSecureOk")
	proto.RegisterType((*ConnectionTune)(nil), "amqp.ConnectionTune")
	proto.RegisterType((*ConnectionTuneOk)(nil), "amqp.ConnectionTuneOk")
	proto.RegisterType((*ConnectionOpen)(nil), "amqp.ConnectionOpen")
	proto.RegisterType((*ConnectionOpenOk)(nil), "amqp.ConnectionOpenOk")
	proto.RegisterType((*ConnectionClose)(nil), "amqp.ConnectionClose")
	proto.RegisterType((*ConnectionCloseOk)(nil), "amqp.ConnectionCloseOk")
	proto.RegisterType((*ConnectionBlocked)(nil), "amqp.ConnectionBlocked")
	proto.RegisterType((*ConnectionUnblocked)(nil), "amqp.ConnectionUnblocked")
	proto.RegisterType((*ChannelOpen)(nil), "amqp.ChannelOpen")
	proto.RegisterType((*ChannelOpenOk)(nil), "amqp.ChannelOpenOk")
	proto.RegisterType((*ChannelFlow)(nil), "amqp.ChannelFlow")
	proto.RegisterType((*ChannelFlowOk)(nil), "amqp.ChannelFlowOk")
	proto.RegisterType((*ChannelClose)(nil), "amqp.ChannelClose")
	proto.RegisterType((*ChannelCloseOk)(nil), "amqp.ChannelCloseOk")
	proto.RegisterType((*ExchangeDeclare)(nil), "amqp.ExchangeDeclare")
	proto.RegisterType((*ExchangeDeclareOk)(nil), "amqp.ExchangeDeclareOk")
	proto.RegisterType((*ExchangeDelete)(nil), "amqp.ExchangeDelete")
	proto.RegisterType((*ExchangeDeleteOk)(nil), "amqp.ExchangeDeleteOk")
	proto.RegisterType((*ExchangeBind)(nil), "amqp.ExchangeBind")
	proto.RegisterType((*ExchangeBindOk)(nil), "amqp.ExchangeBindOk")
	proto.RegisterType((*ExchangeUnbind)(nil), "amqp.ExchangeUnbind")
	proto.RegisterType((*ExchangeUnbindOk)(nil), "amqp.ExchangeUnbindOk")
	proto.RegisterType((*QueueDeclare)(nil), "amqp.QueueDeclare")
	proto.RegisterType((*QueueDeclareOk)(nil), "amqp.QueueDeclareOk")
	proto.RegisterType((*QueueBind)(nil), "amqp.QueueBind")
	proto.RegisterType((*QueueBindOk)(nil), "amqp.QueueBindOk")
	proto.RegisterType((*QueueUnbind)(nil), "amqp.QueueUnbind")
	proto.RegisterType((*QueueUnbindOk)(nil), "amqp.QueueUnbindOk")
	proto.RegisterType((*QueuePurge)(nil), "amqp.QueuePurge")
	proto.RegisterType((*QueuePurgeOk)(nil), "amqp.QueuePurgeOk")
	proto.RegisterType((*QueueDelete)(nil), "amqp.QueueDelete")
	proto.RegisterType((*QueueDeleteOk)(nil), "amqp.QueueDeleteOk")
	proto.RegisterType((*BasicContentHeaderProperties)(nil), "amqp.BasicContentHeaderProperties")
	proto.RegisterType((*BasicQos)(nil), "amqp.BasicQos")
	proto.RegisterType((*BasicQosOk)(nil), "amqp.BasicQosOk")
	proto.RegisterType((*BasicConsume)(nil), "amqp.BasicConsume")
	proto.RegisterType((*BasicConsumeOk)(nil), "amqp.BasicConsumeOk")
	proto.RegisterType((*BasicCancel)(nil), "amqp.BasicCancel")
	proto.RegisterType((*BasicCancelOk)(nil), "amqp.BasicCancelOk")
	proto.RegisterType((*BasicPublish)(nil), "amqp.BasicPublish")
	proto.RegisterType((*BasicReturn)(nil), "amqp.BasicReturn")
	proto.RegisterType((*BasicDeliver)(nil), "amqp.BasicDeliver")
	proto.RegisterType((*BasicGet)(nil), "amqp.BasicGet")
	proto.RegisterType((*BasicGetOk)(nil), "amqp.BasicGetOk")
	proto.RegisterType((*BasicGetEmpty)(nil), "amqp.BasicGetEmpty")
	proto.RegisterType((*BasicAck)(nil), "amqp.BasicAck")
	proto.RegisterType((*BasicReject)(nil), "amqp.BasicReject")
	proto.RegisterType((*BasicRecoverAsync)(nil), "amqp.BasicRecoverAsync")
	proto.RegisterType((*BasicRecover)(nil), "amqp.BasicRecover")
	proto.RegisterType((*BasicRecoverOk)(nil), "amqp.BasicRecoverOk")
	proto.RegisterType((*BasicNack)(nil), "amqp.BasicNack")
	proto.RegisterType((*TxSelect)(nil), "amqp.TxSelect")
	proto.RegisterType((*TxSelectOk)(nil), "amqp.TxSelectOk")
	proto.RegisterType((*TxCommit)(nil), "amqp.TxCommit")
	proto.RegisterType((*TxCommitOk)(nil), "amqp.TxCommitOk")
	proto.RegisterType((*TxRollback)(nil), "amqp.TxRollback")
	proto.RegisterType((*TxRollbackOk)(nil), "amqp.TxRollbackOk")
	proto.RegisterType((*ConfirmSelect)(nil), "amqp.ConfirmSelect")
	proto.RegisterType((*ConfirmSelectOk)(nil), "amqp.ConfirmSelectOk")
}

func init() {
	proto.RegisterFile("github.com/karelbilek/amqp-test-server/amqp/protocol_generated.proto", fileDescriptor_1dd71637af170cde)
}

var fileDescriptor_1dd71637af170cde = []byte{
	// 1961 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x59, 0xcf, 0x6f, 0x1c, 0x49,
	0xf5, 0x4f, 0xc7, 0xe3, 0xf9, 0xf1, 0x66, 0xc6, 0x49, 0xfa, 0xfb, 0x85, 0x9d, 0xf5, 0x26, 0xb6,
	0x63, 0xc8, 0x26, 0xd1, 0x92, 0x58, 0x89, 0xb4, 0xec, 0x6a, 0x57, 0x48, 0xac, 0x27, 0x61, 0xd7,
	0x82, 0xe0, 0xec, 0xc4, 0x11, 0xc7, 0xa6, 0xa6, 0xfb, 0x79, 0xa6, 0x76, 0xba, 0xab, 0x7a, 0xab,
	0xab, 0x1d, 0xcf, 0x72, 0x80, 0x23, 0x12, 0x12, 0x27, 0x8e, 0x08, 0xc1, 0x9d, 0x23, 0x88, 0x7f,
	0x00, 0x89, 0x3d, 0xee, 0x05, 0x81, 0x84, 0xb4, 0x42, 0xb9, 0x70, 0x47, 0xe2, 0x82, 0x84, 0x40,
	0x55, 0x5d, 0x3d, 0x53, 0x35, 0x1e, 0xdb, 0x13, 0xe3, 0xe5, 0x87, 0xb8, 0x44, 0xe9, 0xcf, 0x7b,
	0xaf, 0xea, 0xfd, 0x7e, 0x6f, 0xca, 0xf0, 0xf6, 0x80, 0xca, 0x61, 0xde, 0xbf, 0x1b, 0xf2, 0x64,
	0x0b, 0x05, 0xc3, 0x4c, 0x8a, 0x70, 0x2b, 0xa2, 0x59, 0x4a, 0x64, 0x38, 0x8c, 0xb6, 0x48, 0xf2,
	0x61, 0xba, 0x95, 0x0a, 0x2e, 0x79, 0xc8, 0xe3, 0x60, 0x80, 0x0c, 0x05, 0x91, 0x18, 0xdd, 0xd5,
	0x90, 0x5f, 0x51, 0xe4, 0xd5, 0x3b, 0xd6, 0x11, 0x03, 0x3e, 0xe0, 0x05, 0x7f, 0x3f, 0xdf, 0xd7,
	0x5f, 0xfa, 0x43, 0xff, 0xaf, 0x10, 0x72, 0xd8, 0x8f, 0xbb, 0x51, 0xfd, 0x53, 0xb0, 0x6f, 0xfe,
	0xc5, 0x83, 0x4b, 0x5d, 0xce, 0x18, 0x86, 0x92, 0x72, 0xf6, 0x44, 0x12, 0x21, 0xfd, 0x7b, 0xd0,
	0x3e, 0x40, 0x91, 0x51, 0xce, 0x82, 0x84, 0x7c, 0xc0, 0x45, 0xc7, 0xdb, 0xf0, 0x6e, 0xb5, 0xb7,
	0x5b, 0x1f, 0x7f, 0xba, 0x7e, 0xe1, 0xaf, 0x9f, 0xae, 0x57, 0xfa, 0x63, 0x89, 0xbd, 0x96, 0x61,
	0x79, 0xa4, 0x38, 0x1c, 0x11, 0xca, 0xb8, 0xe8, 0x5c, 0x3c, 0x49, 0x44, 0x71, 0xf8, 0x6f, 0xc2,
	0x95, 0x0c, 0xc5, 0x01, 0x8a, 0x20, 0x15, 0x3c, 0x45, 0x21, 0x29, 0x66, 0x9d, 0xa5, 0x0d, 0xef,
	0x56, 0xf3, 0x7e, 0xf3, 0xae, 0xd6, 0x70, 0x8f, 0xf4, 0x63, 0xec, 0x5d, 0x2e, 0xb8, 0x1e, 0x4f,
	0x98, 0xfc, 0x35, 0x80, 0x04, 0xc3, 0x21, 0x61, 0x34, 0x4b, 0xb2, 0x4e, 0x65, 0xc3, 0xbb, 0xd5,
	0xea, 0x59, 0x88, 0xdf, 0x81, 0x5a, 0xcc, 0x43, 0x12, 0x63, 0xd6, 0x59, 0xd6, 0xc4, 0xf2, 0xf3,
	0xad, 0xfa, 0xf7, 0x7f, 0xba, 0x7e, 0xe1, 0x93, 0x9f, 0xad, 0x5f, 0xd8, 0xfc, 0xa5, 0x07, 0x57,
	0x66, 0xec, 0xde, 0x1d, 0x29, 0x9d, 0xc2, 0x98, 0x22, 0x93, 0xb6, 0x4e, 0xde, 0x1c, 0x9d, 0x0a,
	0x2e, 0x4b, 0xa7, 0x4d, 0x68, 0x4c, 0x34, 0xd0, 0xc6, 0x37, 0xb6, 0x2b, 0xca, 0xf8, 0xde, 0x14,
	0xf6, 0x57, 0xa1, 0x2e, 0x30, 0x4b, 0x39, 0xcb, 0x50, 0x1b, 0xda, 0xea, 0x4d, 0xbe, 0xfd, 0xab,
	0x50, 0x2d, 0x94, 0xd4, 0xf6, 0x94, 0xc2, 0x06, 0xb3, 0xf4, 0x7e, 0x0b, 0x2e, 0x5b, 0x6a, 0x63,
	0x98, 0x0b, 0x25, 0xdb, 0x08, 0x87, 0x24, 0x8e, 0x91, 0x0d, 0x50, 0x6b, 0xdb, 0xea, 0x4d, 0x01,
	0x47, 0xd6, 0x9f, 0x95, 0xdd, 0x1d, 0x39, 0x5a, 0x79, 0xae, 0x56, 0x96, 0xec, 0x8f, 0x3d, 0x58,
	0x99, 0x0a, 0xef, 0xe5, 0x0c, 0xfd, 0x2d, 0x68, 0x2a, 0xcb, 0x18, 0xc6, 0x41, 0x42, 0x0e, 0x4d,
	0x92, 0xac, 0x98, 0x88, 0x57, 0x73, 0xca, 0xe4, 0xbd, 0x2f, 0xf7, 0xc0, 0xb0, 0x3c, 0x22, 0x87,
	0xfe, 0x75, 0x68, 0xec, 0x0b, 0x92, 0xa0, 0x66, 0x2f, 0x12, 0xa4, 0x30, 0xb3, 0xae, 0x61, 0xc5,
	0xf2, 0x25, 0x68, 0x0c, 0x91, 0x08, 0xd9, 0x47, 0x22, 0xb5, 0x8f, 0x8e, 0x9e, 0x38, 0x65, 0xb0,
	0xd4, 0xfb, 0x89, 0x67, 0xfb, 0x45, 0xa9, 0xb7, 0x3b, 0xfa, 0x8f, 0x52, 0xf0, 0x07, 0x8e, 0xff,
	0x76, 0x53, 0x64, 0xfe, 0x4d, 0x68, 0x1d, 0x50, 0x21, 0x73, 0x12, 0x07, 0x43, 0x9e, 0x49, 0xad,
	0x5f, 0x19, 0xf8, 0xa6, 0xa1, 0xbc, 0xc7, 0x33, 0xa9, 0x72, 0x4b, 0xa0, 0xae, 0x82, 0xe8, 0x9e,
	0x9b, 0x5b, 0x13, 0xd8, 0xe6, 0xb9, 0xaf, 0xf5, 0xaa, 0xcf, 0xf2, 0xdc, 0xb7, 0xb4, 0xf9, 0xaa,
	0xed, 0x2d, 0xa5, 0xcc, 0xee, 0xc8, 0xbd, 0xc5, 0x9b, 0x7b, 0x8b, 0x75, 0xc2, 0x6f, 0x9c, 0xbe,
	0xd1, 0x8d, 0x79, 0x86, 0xfe, 0x1d, 0x00, 0x81, 0x69, 0x3c, 0x0e, 0x42, 0x1e, 0xe1, 0x31, 0xee,
	0x6e, 0x68, 0x8e, 0x2e, 0x8f, 0xd0, 0xff, 0x42, 0xc9, 0x2e, 0xf1, 0x50, 0xce, 0xda, 0x95, 0xc6,
	0xe3, 0x3d, 0x3c, 0x94, 0xfe, 0x6d, 0xa8, 0x87, 0x31, 0xc9, 0xb2, 0x80, 0x46, 0xc7, 0xb8, 0xbb,
	0xa6, 0xe9, 0x3b, 0x91, 0xff, 0x9a, 0x2a, 0x41, 0x39, 0xe4, 0x91, 0xe2, 0xad, 0xcc, 0xe5, 0xad,
	0x17, 0x0c, 0x3b, 0x91, 0x65, 0xc9, 0x35, 0xbb, 0x11, 0x68, 0x43, 0x76, 0x47, 0x16, 0xf9, 0x6d,
	0x9b, 0xbc, 0x1d, 0xf3, 0x70, 0x84, 0x91, 0xaa, 0x56, 0x81, 0x24, 0xe3, 0xcc, 0x71, 0x94, 0xc1,
	0x2c, 0xe1, 0x75, 0xf8, 0xbf, 0xa9, 0xf0, 0x53, 0xd6, 0x2f, 0xc4, 0x9d, 0xd3, 0x9b, 0xdd, 0x22,
	0xff, 0x74, 0x4a, 0xbc, 0x58, 0x0c, 0xde, 0x80, 0xb6, 0x25, 0xbc, 0x3b, 0x52, 0x8d, 0xc0, 0x15,
	0x6f, 0xcd, 0x17, 0x7c, 0x7d, 0x72, 0xeb, 0xd7, 0x62, 0xfe, 0x4c, 0x59, 0x43, 0x42, 0x49, 0x0f,
	0x8a, 0x98, 0x95, 0x89, 0x63, 0xb0, 0xb9, 0xf7, 0x29, 0x31, 0x7d, 0xdf, 0x62, 0x82, 0xbf, 0xf6,
	0xa0, 0x65, 0x24, 0xff, 0x9b, 0x33, 0x65, 0x15, 0x56, 0x6c, 0x2b, 0x9c, 0x34, 0xf9, 0xfd, 0x45,
	0xb8, 0xf4, 0xf0, 0x50, 0xf5, 0x92, 0x01, 0x3e, 0xc0, 0x30, 0x26, 0x02, 0x55, 0xaf, 0x70, 0xc3,
	0x31, 0xd7, 0xc8, 0xb2, 0x82, 0x37, 0xa0, 0x8e, 0xe6, 0x00, 0xc7, 0xc4, 0x09, 0xea, 0x77, 0xa0,
	0x22, 0xc7, 0x69, 0x31, 0x3b, 0x4a, 0xaa, 0x46, 0xfc, 0x35, 0xa8, 0xa5, 0x24, 0xcb, 0x54, 0x24,
	0x2a, 0x56, 0x24, 0x4a, 0x50, 0xd1, 0xa3, 0x5c, 0xa8, 0xd1, 0xa5, 0x27, 0xe2, 0x84, 0x6e, 0x40,
	0xff, 0x06, 0x34, 0x49, 0x2e, 0x79, 0x10, 0x61, 0x8c, 0x12, 0x3b, 0x55, 0x8b, 0x07, 0x14, 0xe1,
	0x81, 0xc6, 0x95, 0x8a, 0x94, 0x49, 0x14, 0x8c, 0xc4, 0x9d, 0x9a, 0xc5, 0x33, 0x41, 0xfd, 0x6b,
	0x50, 0x63, 0x3c, 0x78, 0x46, 0xa8, 0xec, 0xd4, 0xed, 0x94, 0x60, 0xfc, 0x5b, 0x84, 0xaa, 0x18,
	0x35, 0x88, 0x18, 0xe4, 0x09, 0x32, 0x99, 0x75, 0x1a, 0x47, 0xe7, 0xea, 0x94, 0xea, 0x16, 0xe8,
	0x8c, 0x67, 0x1d, 0xcf, 0xff, 0xdc, 0x83, 0x95, 0x29, 0x5d, 0xeb, 0x79, 0xde, 0x8e, 0xbf, 0x0e,
	0x0d, 0xba, 0x1f, 0xe4, 0x2c, 0xcf, 0x30, 0x72, 0x9a, 0x6b, 0x9d, 0xee, 0x3f, 0xd5, 0xa8, 0x6d,
	0x78, 0xe5, 0xa8, 0xe1, 0x96, 0xba, 0x57, 0xe1, 0xb2, 0xab, 0xad, 0x63, 0xcc, 0xdf, 0x3c, 0x68,
	0x95, 0xe4, 0x6d, 0xca, 0xa2, 0x17, 0x34, 0xe5, 0x55, 0x68, 0x46, 0x98, 0x49, 0xca, 0x88, 0x6a,
	0x38, 0x8e, 0x35, 0x36, 0x41, 0x15, 0x6e, 0xc6, 0x73, 0x11, 0xba, 0xb9, 0x64, 0x30, 0x95, 0x0d,
	0x82, 0xe7, 0x92, 0xb2, 0x41, 0x30, 0xc2, 0xb1, 0xb3, 0x90, 0x80, 0x21, 0x7c, 0x1d, 0xc7, 0xb6,
	0xc9, 0xcb, 0xa7, 0xc5, 0xba, 0xba, 0x60, 0xac, 0x57, 0xa7, 0xb1, 0x54, 0xe6, 0x3b, 0xbe, 0xf9,
	0xbb, 0x15, 0xe8, 0xa7, 0xac, 0xff, 0x3f, 0xe8, 0x1d, 0x2b, 0x77, 0x0a, 0x07, 0x38, 0xfe, 0xf9,
	0xd5, 0x45, 0x68, 0xbd, 0x9f, 0x63, 0x7e, 0xc6, 0xfe, 0xb3, 0x0a, 0xcb, 0x1f, 0x2a, 0x69, 0xc7,
	0x2f, 0x05, 0x64, 0xf7, 0x97, 0xa5, 0x53, 0xfa, 0x4b, 0x65, 0x5e, 0x7f, 0xd9, 0x84, 0x06, 0x1e,
	0x86, 0x71, 0xae, 0x4f, 0xb0, 0xdd, 0x31, 0x85, 0x17, 0xed, 0x41, 0x96, 0x5f, 0x6b, 0xa7, 0xf9,
	0xb5, 0xbe, 0xa0, 0x5f, 0x7f, 0xe8, 0xc1, 0x8a, 0xed, 0x39, 0xbd, 0x15, 0x1b, 0x6f, 0x78, 0x47,
	0xbd, 0x71, 0x1b, 0xda, 0x09, 0x66, 0x19, 0x19, 0x60, 0x10, 0xf2, 0x9c, 0x49, 0x67, 0x55, 0x6c,
	0x19, 0x52, 0x57, 0x51, 0xfc, 0xd7, 0x60, 0x25, 0xe4, 0x2c, 0xcb, 0x13, 0x14, 0x86, 0x77, 0xc9,
	0xe2, 0x6d, 0x97, 0x34, 0xcd, 0x6c, 0x29, 0xf4, 0x67, 0x0f, 0x1a, 0x5a, 0xa1, 0x33, 0xf4, 0x80,
	0x93, 0xe2, 0x68, 0xb7, 0xba, 0xa5, 0xb9, 0xad, 0xee, 0xdf, 0x98, 0xdd, 0x2f, 0x41, 0x73, 0x62,
	0xb3, 0x93, 0xd8, 0xbf, 0xf5, 0x0c, 0xe5, 0x4c, 0x55, 0xff, 0x2f, 0xf1, 0x87, 0x63, 0xf0, 0xf2,
	0x82, 0x06, 0xbf, 0x0c, 0x6d, 0xcb, 0x2c, 0xc7, 0xe4, 0xef, 0x02, 0x68, 0xd2, 0xe3, 0x5c, 0x0c,
	0xce, 0xb3, 0x90, 0xad, 0xb8, 0x2d, 0x9d, 0x38, 0xa6, 0xba, 0xa6, 0x97, 0x68, 0x05, 0x76, 0x47,
	0x47, 0x73, 0xde, 0x3b, 0x2e, 0xe7, 0xdd, 0xbd, 0xaf, 0x69, 0xea, 0xea, 0x0c, 0x73, 0xf9, 0x24,
	0x3b, 0x16, 0x98, 0xc8, 0xeb, 0x50, 0xa7, 0xfb, 0x01, 0x26, 0xa9, 0x1c, 0xbb, 0x4d, 0x89, 0xee,
	0x3f, 0x54, 0xe0, 0x29, 0x39, 0x6c, 0x99, 0xf1, 0xc0, 0xc4, 0xa9, 0x9c, 0xd7, 0x67, 0x73, 0xc6,
	0x9f, 0x96, 0xe0, 0xea, 0x36, 0xc9, 0x68, 0xd8, 0xe5, 0x4c, 0x22, 0x93, 0xef, 0x21, 0x89, 0x9c,
	0x67, 0x8d, 0xeb, 0xd0, 0x0a, 0x0b, 0x52, 0xa0, 0xd7, 0x3c, 0xdd, 0x79, 0x7a, 0x4d, 0x83, 0xed,
	0xa9, 0x3d, 0xef, 0x36, 0x5c, 0x2e, 0x59, 0x90, 0x85, 0x3c, 0xa2, 0x6c, 0x50, 0x78, 0xa7, 0x77,
	0xc9, 0xe0, 0x0f, 0x0d, 0xec, 0xdf, 0x80, 0xda, 0x50, 0xdf, 0x30, 0xf7, 0x51, 0xa5, 0xa4, 0xf9,
	0x77, 0xa0, 0x1d, 0x61, 0x4c, 0x0f, 0x50, 0x8c, 0x83, 0x44, 0x2d, 0xe3, 0xc5, 0x3a, 0x5c, 0x9f,
	0x3e, 0xda, 0x94, 0xe4, 0x47, 0x6a, 0x13, 0xff, 0x22, 0xd4, 0x53, 0x41, 0xb9, 0xa0, 0x72, 0xac,
	0x9d, 0x66, 0x73, 0x4e, 0x28, 0xfe, 0x0d, 0xd5, 0xf5, 0x84, 0xc0, 0x58, 0xcf, 0x53, 0xb5, 0x64,
	0x57, 0xb5, 0x92, 0x6d, 0x0b, 0xdd, 0x89, 0xfc, 0x97, 0xa1, 0x6e, 0xd6, 0x7a, 0xae, 0x7b, 0x79,
	0xa3, 0x57, 0x2b, 0xd6, 0x79, 0xee, 0xaf, 0x01, 0xe0, 0x61, 0x4a, 0x45, 0x31, 0xa9, 0xeb, 0x9a,
	0x68, 0x21, 0xfe, 0x35, 0x80, 0x32, 0x02, 0x34, 0xd2, 0x9b, 0x64, 0xa3, 0xd7, 0x30, 0xc8, 0x8e,
	0xfa, 0x7d, 0xd6, 0x90, 0x34, 0xc1, 0x4c, 0x92, 0x24, 0xed, 0xc0, 0x86, 0x77, 0xab, 0xd2, 0x9b,
	0x02, 0xbe, 0x6f, 0xf6, 0xe8, 0xa6, 0x16, 0x2b, 0x36, 0xe8, 0x97, 0xa0, 0x96, 0x67, 0x28, 0xd4,
	0x69, 0x2d, 0x0d, 0x57, 0xd5, 0xe7, 0x4e, 0xe4, 0x7f, 0x0e, 0xaa, 0x24, 0x4d, 0x15, 0xde, 0xd6,
	0xf8, 0x32, 0x49, 0xd3, 0x9d, 0xc8, 0xbc, 0x9a, 0xe8, 0x4c, 0xed, 0xac, 0x68, 0xc2, 0xe4, 0x7b,
	0xf3, 0x47, 0x1e, 0xd4, 0x75, 0xa4, 0xdf, 0xe7, 0x99, 0xca, 0x95, 0x54, 0xe0, 0x3e, 0xca, 0x70,
	0x18, 0x64, 0xf4, 0x23, 0x74, 0x73, 0xa5, 0x24, 0x3d, 0xa1, 0x1f, 0xa1, 0xff, 0x3a, 0xac, 0x4c,
	0x58, 0xed, 0xc1, 0x32, 0x5b, 0x23, 0x93, 0x03, 0x8b, 0x19, 0x73, 0x15, 0xaa, 0x83, 0x98, 0xf7,
	0x49, 0xec, 0x96, 0x74, 0x81, 0x59, 0x09, 0xf8, 0x79, 0x80, 0x52, 0xab, 0x23, 0x7b, 0x43, 0x99,
	0x98, 0x6a, 0x1a, 0x9d, 0x63, 0x99, 0xde, 0xd4, 0x29, 0x5d, 0x8c, 0x3f, 0x49, 0x06, 0x4e, 0x8f,
	0x6d, 0x96, 0x94, 0x3d, 0x32, 0x50, 0xc5, 0xca, 0x78, 0xa0, 0x5f, 0xbb, 0xdc, 0x62, 0x65, 0xfc,
	0x1b, 0x0a, 0xf4, 0x5f, 0x81, 0x2a, 0xe3, 0x01, 0x09, 0x47, 0x4e, 0xad, 0x2e, 0x33, 0xfe, 0x4e,
	0x38, 0x72, 0xd7, 0x8b, 0xea, 0xfc, 0xf5, 0xe2, 0xb3, 0xd8, 0x1b, 0xba, 0xb0, 0x62, 0x3b, 0x6e,
	0x77, 0x74, 0xc4, 0x60, 0xef, 0x18, 0x83, 0xad, 0x43, 0x02, 0x68, 0x16, 0x87, 0x10, 0x16, 0x62,
	0xbc, 0xf0, 0x09, 0xb6, 0x41, 0x17, 0x4f, 0x6c, 0x5f, 0xdb, 0xd0, 0xb6, 0x2e, 0x38, 0x9b, 0x92,
	0xbf, 0xf3, 0x4c, 0x8e, 0x3c, 0xce, 0xfb, 0x31, 0xcd, 0x86, 0xe7, 0xfe, 0x13, 0x6b, 0x66, 0xce,
	0x2e, 0x1d, 0x33, 0x67, 0x37, 0xa1, 0x91, 0x10, 0x16, 0x11, 0xc9, 0x85, 0xdb, 0xd5, 0xa7, 0xb0,
	0xe2, 0xa1, 0x49, 0x82, 0x11, 0x25, 0x72, 0x66, 0xd9, 0x9c, 0xc0, 0x96, 0x65, 0xbf, 0xf0, 0x8c,
	0xff, 0x7b, 0x28, 0x73, 0xc1, 0x3e, 0x93, 0xa7, 0x89, 0xf3, 0x5a, 0x33, 0x2c, 0xb5, 0xff, 0x50,
	0x06, 0xe4, 0x41, 0xd1, 0x9e, 0x17, 0xcf, 0x9b, 0x9b, 0x30, 0x69, 0xe9, 0x9a, 0x51, 0xe9, 0x5c,
	0x99, 0xfe, 0x0c, 0x2a, 0x28, 0x8a, 0xf1, 0x55, 0x68, 0x0a, 0x34, 0xc0, 0xcc, 0x94, 0xb5, 0x09,
	0x8e, 0x75, 0x95, 0x45, 0xac, 0x5b, 0x3e, 0xd5, 0xba, 0xef, 0x98, 0x06, 0xfa, 0x2e, 0xca, 0x73,
	0xec, 0x46, 0xd3, 0x1e, 0xb2, 0x74, 0xa4, 0x87, 0xb8, 0xae, 0x85, 0xf2, 0xf6, 0xa2, 0x5a, 0x1c,
	0x7f, 0x79, 0x0b, 0xfa, 0xeb, 0xe2, 0x22, 0xfe, 0xfa, 0x27, 0x97, 0xce, 0x99, 0x35, 0x64, 0x79,
	0x81, 0x35, 0xe4, 0x2b, 0xa6, 0x1b, 0xbc, 0x8b, 0xb2, 0x58, 0x83, 0x5e, 0xec, 0xcd, 0x31, 0x30,
	0x91, 0x51, 0x6d, 0x77, 0x61, 0xcf, 0x6c, 0x40, 0x3d, 0xc9, 0x63, 0x49, 0xd3, 0x18, 0x1d, 0xb7,
	0x4c, 0x50, 0xeb, 0x82, 0x6f, 0x4f, 0xca, 0xf1, 0x03, 0x0c, 0xe5, 0xe2, 0x77, 0xac, 0x41, 0x4d,
	0xe0, 0x34, 0xf4, 0x93, 0x01, 0x62, 0x40, 0xc7, 0x03, 0x57, 0xcc, 0x0d, 0x21, 0x3f, 0x40, 0xf1,
	0x4e, 0x36, 0x66, 0xa1, 0x2d, 0xee, 0x9d, 0x2c, 0xfe, 0xa6, 0x29, 0x3c, 0x23, 0xfe, 0x02, 0x92,
	0xab, 0x66, 0x5c, 0x18, 0x49, 0x67, 0x08, 0x7f, 0xcf, 0x83, 0x86, 0x26, 0x7e, 0x93, 0x9c, 0xab,
	0x67, 0x6d, 0xf5, 0x96, 0x4e, 0x56, 0xef, 0xff, 0xa1, 0xbe, 0x77, 0xf8, 0x04, 0x63, 0x0c, 0xa5,
	0xbb, 0x35, 0x94, 0xa8, 0xa3, 0xb0, 0xe6, 0xee, 0xf2, 0x24, 0xa1, 0x47, 0xb8, 0x0b, 0xd4, 0xe1,
	0xd6, 0x78, 0x8f, 0xc7, 0x71, 0x9f, 0x38, 0xb5, 0xd6, 0x81, 0xd6, 0x14, 0x77, 0x24, 0xde, 0x80,
	0x76, 0x97, 0xb3, 0x7d, 0x2a, 0x92, 0xe2, 0x72, 0xb5, 0xe6, 0x30, 0xae, 0xc7, 0x9d, 0xe7, 0x8e,
	0xbb, 0x67, 0xee, 0xb8, 0x7b, 0x45, 0xff, 0x61, 0x62, 0x2a, 0x68, 0x9f, 0xba, 0xdd, 0xfa, 0xf8,
	0xf9, 0x9a, 0xf7, 0xc9, 0xf3, 0x35, 0xef, 0x8f, 0xcf, 0xd7, 0xbc, 0x7f, 0x04, 0x00, 0x00, 0xff,
	0xff, 0x15, 0x56, 0x3c, 0xa7, 0x9e, 0x1d, 0x00, 0x00,
}

func (m *ConnectionStart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionStart) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.VersionMajor))
	dAtA[i] = 0x10
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.VersionMinor))
	if m.ServerProperties != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.ServerProperties.Size()))
		n1, err1 := m.ServerProperties.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.Mechanisms != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Mechanisms)))
		i += copy(dAtA[i:], m.Mechanisms)
	}
	if m.Locales != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Locales)))
		i += copy(dAtA[i:], m.Locales)
	}
	return i, nil
}

func (m *ConnectionStartOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionStartOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientProperties != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.ClientProperties.Size()))
		n2, err2 := m.ClientProperties.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Mechanism)))
	i += copy(dAtA[i:], m.Mechanism)
	if m.Response != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Response)))
		i += copy(dAtA[i:], m.Response)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Locale)))
	i += copy(dAtA[i:], m.Locale)
	return i, nil
}

func (m *ConnectionSecure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionSecure) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Challenge != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Challenge)))
		i += copy(dAtA[i:], m.Challenge)
	}
	return i, nil
}

func (m *ConnectionSecureOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionSecureOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Response != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Response)))
		i += copy(dAtA[i:], m.Response)
	}
	return i, nil
}

func (m *ConnectionTune) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionTune) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.ChannelMax))
	dAtA[i] = 0x10
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.FrameMax))
	dAtA[i] = 0x18
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Heartbeat))
	return i, nil
}

func (m *ConnectionTuneOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionTuneOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.ChannelMax))
	dAtA[i] = 0x10
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.FrameMax))
	dAtA[i] = 0x18
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Heartbeat))
	return i, nil
}

func (m *ConnectionOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionOpen) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.VirtualHost)))
	i += copy(dAtA[i:], m.VirtualHost)
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Reserved1)))
	i += copy(dAtA[i:], m.Reserved1)
	dAtA[i] = 0x18
	i++
	if m.Reserved2 {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *ConnectionOpenOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionOpenOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Reserved1)))
	i += copy(dAtA[i:], m.Reserved1)
	return i, nil
}

func (m *ConnectionClose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionClose) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.ReplyCode))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.ReplyText)))
	i += copy(dAtA[i:], m.ReplyText)
	dAtA[i] = 0x18
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.ClassId))
	dAtA[i] = 0x20
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.MethodId))
	return i, nil
}

func (m *ConnectionCloseOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionCloseOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ConnectionBlocked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionBlocked) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Reason)))
	i += copy(dAtA[i:], m.Reason)
	return i, nil
}

func (m *ConnectionUnblocked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectionUnblocked) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ChannelOpen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelOpen) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Reserved1)))
	i += copy(dAtA[i:], m.Reserved1)
	return i, nil
}

func (m *ChannelOpenOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelOpenOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reserved1 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Reserved1)))
		i += copy(dAtA[i:], m.Reserved1)
	}
	return i, nil
}

func (m *ChannelFlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelFlow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Active {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *ChannelFlowOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelFlowOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Active {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *ChannelClose) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelClose) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.ReplyCode))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.ReplyText)))
	i += copy(dAtA[i:], m.ReplyText)
	dAtA[i] = 0x18
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.ClassId))
	dAtA[i] = 0x20
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.MethodId))
	return i, nil
}

func (m *ChannelCloseOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelCloseOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ExchangeDeclare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeDeclare) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Exchange)))
	i += copy(dAtA[i:], m.Exchange)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Type)))
	i += copy(dAtA[i:], m.Type)
	dAtA[i] = 0x20
	i++
	if m.Passive {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.Durable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x30
	i++
	if m.AutoDelete {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	if m.Internal {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x40
	i++
	if m.NoWait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Arguments != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Arguments.Size()))
		n3, err3 := m.Arguments.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	return i, nil
}

func (m *ExchangeDeclareOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeDeclareOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ExchangeDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeDelete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Exchange)))
	i += copy(dAtA[i:], m.Exchange)
	dAtA[i] = 0x18
	i++
	if m.IfUnused {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.NoWait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *ExchangeDeleteOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeDeleteOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ExchangeBind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeBind) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Destination)))
	i += copy(dAtA[i:], m.Destination)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Source)))
	i += copy(dAtA[i:], m.Source)
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.RoutingKey)))
	i += copy(dAtA[i:], m.RoutingKey)
	dAtA[i] = 0x28
	i++
	if m.NoWait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Arguments != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Arguments.Size()))
		n4, err4 := m.Arguments.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	return i, nil
}

func (m *ExchangeBindOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeBindOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ExchangeUnbind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeUnbind) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Destination)))
	i += copy(dAtA[i:], m.Destination)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Source)))
	i += copy(dAtA[i:], m.Source)
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.RoutingKey)))
	i += copy(dAtA[i:], m.RoutingKey)
	dAtA[i] = 0x28
	i++
	if m.NoWait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Arguments != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Arguments.Size()))
		n5, err5 := m.Arguments.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	return i, nil
}

func (m *ExchangeUnbindOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeUnbindOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *QueueDeclare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueDeclare) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Queue)))
	i += copy(dAtA[i:], m.Queue)
	dAtA[i] = 0x18
	i++
	if m.Passive {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.Durable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.Exclusive {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x30
	i++
	if m.AutoDelete {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	if m.NoWait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Arguments != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Arguments.Size()))
		n6, err6 := m.Arguments.MarshalTo(dAtA[i:])
		if err6 != nil {
			return 0, err6
		}
		i += n6
	}
	return i, nil
}

func (m *QueueDeclareOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueDeclareOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Queue)))
	i += copy(dAtA[i:], m.Queue)
	dAtA[i] = 0x10
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.MessageCount))
	dAtA[i] = 0x18
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.ConsumerCount))
	return i, nil
}

func (m *QueueBind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueBind) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Queue)))
	i += copy(dAtA[i:], m.Queue)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Exchange)))
	i += copy(dAtA[i:], m.Exchange)
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.RoutingKey)))
	i += copy(dAtA[i:], m.RoutingKey)
	dAtA[i] = 0x28
	i++
	if m.NoWait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Arguments != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Arguments.Size()))
		n7, err7 := m.Arguments.MarshalTo(dAtA[i:])
		if err7 != nil {
			return 0, err7
		}
		i += n7
	}
	return i, nil
}

func (m *QueueBindOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueBindOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *QueueUnbind) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueUnbind) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Queue)))
	i += copy(dAtA[i:], m.Queue)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Exchange)))
	i += copy(dAtA[i:], m.Exchange)
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.RoutingKey)))
	i += copy(dAtA[i:], m.RoutingKey)
	if m.Arguments != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Arguments.Size()))
		n8, err8 := m.Arguments.MarshalTo(dAtA[i:])
		if err8 != nil {
			return 0, err8
		}
		i += n8
	}
	return i, nil
}

func (m *QueueUnbindOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueUnbindOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *QueuePurge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuePurge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Queue)))
	i += copy(dAtA[i:], m.Queue)
	dAtA[i] = 0x18
	i++
	if m.NoWait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *QueuePurgeOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueuePurgeOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.MessageCount))
	return i, nil
}

func (m *QueueDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueDelete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Queue)))
	i += copy(dAtA[i:], m.Queue)
	dAtA[i] = 0x18
	i++
	if m.IfUnused {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.IfEmpty {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.NoWait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *QueueDeleteOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueDeleteOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.MessageCount))
	return i, nil
}

func (m *BasicContentHeaderProperties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicContentHeaderProperties) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContentType != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(*m.ContentType)))
		i += copy(dAtA[i:], *m.ContentType)
	}
	if m.ContentEncoding != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(*m.ContentEncoding)))
		i += copy(dAtA[i:], *m.ContentEncoding)
	}
	if m.Headers != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Headers.Size()))
		n9, err9 := m.Headers.MarshalTo(dAtA[i:])
		if err9 != nil {
			return 0, err9
		}
		i += n9
	}
	if m.DeliveryMode != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(*m.DeliveryMode))
	}
	if m.Priority != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(*m.Priority))
	}
	if m.CorrelationId != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(*m.CorrelationId)))
		i += copy(dAtA[i:], *m.CorrelationId)
	}
	if m.ReplyTo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(*m.ReplyTo)))
		i += copy(dAtA[i:], *m.ReplyTo)
	}
	if m.Expiration != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(*m.Expiration)))
		i += copy(dAtA[i:], *m.Expiration)
	}
	if m.MessageId != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(*m.MessageId)))
		i += copy(dAtA[i:], *m.MessageId)
	}
	if m.Timestamp != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(*m.Timestamp))
	}
	if m.Type != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(*m.Type)))
		i += copy(dAtA[i:], *m.Type)
	}
	if m.UserId != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(*m.UserId)))
		i += copy(dAtA[i:], *m.UserId)
	}
	if m.AppId != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(*m.AppId)))
		i += copy(dAtA[i:], *m.AppId)
	}
	if m.Reserved != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(*m.Reserved)))
		i += copy(dAtA[i:], *m.Reserved)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BasicQos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicQos) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.PrefetchSize))
	dAtA[i] = 0x10
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.PrefetchCount))
	dAtA[i] = 0x18
	i++
	if m.Global {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *BasicQosOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicQosOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BasicConsume) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicConsume) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Queue)))
	i += copy(dAtA[i:], m.Queue)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.ConsumerTag)))
	i += copy(dAtA[i:], m.ConsumerTag)
	dAtA[i] = 0x20
	i++
	if m.NoLocal {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.NoAck {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x30
	i++
	if m.Exclusive {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x38
	i++
	if m.NoWait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.Arguments != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Arguments.Size()))
		n10, err10 := m.Arguments.MarshalTo(dAtA[i:])
		if err10 != nil {
			return 0, err10
		}
		i += n10
	}
	return i, nil
}

func (m *BasicConsumeOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicConsumeOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.ConsumerTag)))
	i += copy(dAtA[i:], m.ConsumerTag)
	return i, nil
}

func (m *BasicCancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicCancel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.ConsumerTag)))
	i += copy(dAtA[i:], m.ConsumerTag)
	dAtA[i] = 0x10
	i++
	if m.NoWait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *BasicCancelOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicCancelOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.ConsumerTag)))
	i += copy(dAtA[i:], m.ConsumerTag)
	return i, nil
}

func (m *BasicPublish) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicPublish) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Exchange)))
	i += copy(dAtA[i:], m.Exchange)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.RoutingKey)))
	i += copy(dAtA[i:], m.RoutingKey)
	dAtA[i] = 0x20
	i++
	if m.Mandatory {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x28
	i++
	if m.Immediate {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *BasicReturn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicReturn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.ReplyCode))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.ReplyText)))
	i += copy(dAtA[i:], m.ReplyText)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Exchange)))
	i += copy(dAtA[i:], m.Exchange)
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.RoutingKey)))
	i += copy(dAtA[i:], m.RoutingKey)
	return i, nil
}

func (m *BasicDeliver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicDeliver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.ConsumerTag)))
	i += copy(dAtA[i:], m.ConsumerTag)
	dAtA[i] = 0x10
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.DeliveryTag))
	dAtA[i] = 0x18
	i++
	if m.Redelivered {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Exchange)))
	i += copy(dAtA[i:], m.Exchange)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.RoutingKey)))
	i += copy(dAtA[i:], m.RoutingKey)
	return i, nil
}

func (m *BasicGet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicGet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.Reserved1))
	dAtA[i] = 0x12
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Queue)))
	i += copy(dAtA[i:], m.Queue)
	dAtA[i] = 0x18
	i++
	if m.NoAck {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *BasicGetOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicGetOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.DeliveryTag))
	dAtA[i] = 0x10
	i++
	if m.Redelivered {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x1a
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Exchange)))
	i += copy(dAtA[i:], m.Exchange)
	dAtA[i] = 0x22
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.RoutingKey)))
	i += copy(dAtA[i:], m.RoutingKey)
	dAtA[i] = 0x28
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.MessageCount))
	return i, nil
}

func (m *BasicGetEmpty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicGetEmpty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(len(m.Reserved1)))
	i += copy(dAtA[i:], m.Reserved1)
	return i, nil
}

func (m *BasicAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.DeliveryTag))
	dAtA[i] = 0x10
	i++
	if m.Multiple {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *BasicReject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicReject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.DeliveryTag))
	dAtA[i] = 0x10
	i++
	if m.Requeue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *BasicRecoverAsync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicRecoverAsync) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Requeue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *BasicRecover) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicRecover) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Requeue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *BasicRecoverOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicRecoverOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *BasicNack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicNack) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintProtocolGenerated(dAtA, i, uint64(m.DeliveryTag))
	dAtA[i] = 0x10
	i++
	if m.Multiple {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x18
	i++
	if m.Requeue {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *TxSelect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxSelect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TxSelectOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxSelectOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TxCommit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxCommit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TxCommitOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxCommitOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TxRollback) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRollback) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TxRollbackOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRollbackOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ConfirmSelect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfirmSelect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	if m.Nowait {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *ConfirmSelectOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfirmSelectOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintProtocolGenerated(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ConnectionStart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.VersionMajor))
	n += 1 + sovProtocolGenerated(uint64(m.VersionMinor))
	if m.ServerProperties != nil {
		l = m.ServerProperties.Size()
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.Mechanisms != nil {
		l = len(m.Mechanisms)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.Locales != nil {
		l = len(m.Locales)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *ConnectionStartOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClientProperties != nil {
		l = m.ClientProperties.Size()
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	l = len(m.Mechanism)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	if m.Response != nil {
		l = len(m.Response)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	l = len(m.Locale)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	return n
}

func (m *ConnectionSecure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Challenge != nil {
		l = len(m.Challenge)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *ConnectionSecureOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		l = len(m.Response)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *ConnectionTune) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.ChannelMax))
	n += 1 + sovProtocolGenerated(uint64(m.FrameMax))
	n += 1 + sovProtocolGenerated(uint64(m.Heartbeat))
	return n
}

func (m *ConnectionTuneOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.ChannelMax))
	n += 1 + sovProtocolGenerated(uint64(m.FrameMax))
	n += 1 + sovProtocolGenerated(uint64(m.Heartbeat))
	return n
}

func (m *ConnectionOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VirtualHost)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.Reserved1)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	return n
}

func (m *ConnectionOpenOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reserved1)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	return n
}

func (m *ConnectionClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.ReplyCode))
	l = len(m.ReplyText)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 1 + sovProtocolGenerated(uint64(m.ClassId))
	n += 1 + sovProtocolGenerated(uint64(m.MethodId))
	return n
}

func (m *ConnectionCloseOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ConnectionBlocked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reason)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	return n
}

func (m *ConnectionUnblocked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ChannelOpen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reserved1)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	return n
}

func (m *ChannelOpenOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reserved1 != nil {
		l = len(m.Reserved1)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *ChannelFlow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func (m *ChannelFlowOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func (m *ChannelClose) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.ReplyCode))
	l = len(m.ReplyText)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 1 + sovProtocolGenerated(uint64(m.ClassId))
	n += 1 + sovProtocolGenerated(uint64(m.MethodId))
	return n
}

func (m *ChannelCloseOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ExchangeDeclare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Exchange)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.Type)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *ExchangeDeclareOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ExchangeDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Exchange)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	n += 2
	return n
}

func (m *ExchangeDeleteOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ExchangeBind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Destination)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.Source)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.RoutingKey)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *ExchangeBindOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ExchangeUnbind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Destination)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.Source)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.RoutingKey)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *ExchangeUnbindOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueueDeclare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Queue)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	n += 2
	n += 2
	n += 2
	n += 2
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *QueueDeclareOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Queue)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 1 + sovProtocolGenerated(uint64(m.MessageCount))
	n += 1 + sovProtocolGenerated(uint64(m.ConsumerCount))
	return n
}

func (m *QueueBind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Queue)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.Exchange)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.RoutingKey)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *QueueBindOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueueUnbind) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Queue)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.Exchange)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.RoutingKey)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *QueueUnbindOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueuePurge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Queue)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	return n
}

func (m *QueuePurgeOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.MessageCount))
	return n
}

func (m *QueueDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Queue)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	n += 2
	n += 2
	return n
}

func (m *QueueDeleteOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.MessageCount))
	return n
}

func (m *BasicContentHeaderProperties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContentType != nil {
		l = len(*m.ContentType)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.ContentEncoding != nil {
		l = len(*m.ContentEncoding)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.Headers != nil {
		l = m.Headers.Size()
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.DeliveryMode != nil {
		n += 1 + sovProtocolGenerated(uint64(*m.DeliveryMode))
	}
	if m.Priority != nil {
		n += 1 + sovProtocolGenerated(uint64(*m.Priority))
	}
	if m.CorrelationId != nil {
		l = len(*m.CorrelationId)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.ReplyTo != nil {
		l = len(*m.ReplyTo)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.Expiration != nil {
		l = len(*m.Expiration)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.MessageId != nil {
		l = len(*m.MessageId)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.Timestamp != nil {
		n += 1 + sovProtocolGenerated(uint64(*m.Timestamp))
	}
	if m.Type != nil {
		l = len(*m.Type)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.UserId != nil {
		l = len(*m.UserId)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.AppId != nil {
		l = len(*m.AppId)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.Reserved != nil {
		l = len(*m.Reserved)
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BasicQos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.PrefetchSize))
	n += 1 + sovProtocolGenerated(uint64(m.PrefetchCount))
	n += 2
	return n
}

func (m *BasicQosOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BasicConsume) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Queue)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.ConsumerTag)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	n += 2
	n += 2
	n += 2
	if m.Arguments != nil {
		l = m.Arguments.Size()
		n += 1 + l + sovProtocolGenerated(uint64(l))
	}
	return n
}

func (m *BasicConsumeOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConsumerTag)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	return n
}

func (m *BasicCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConsumerTag)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	return n
}

func (m *BasicCancelOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConsumerTag)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	return n
}

func (m *BasicPublish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Exchange)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.RoutingKey)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	n += 2
	return n
}

func (m *BasicReturn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.ReplyCode))
	l = len(m.ReplyText)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.Exchange)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.RoutingKey)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	return n
}

func (m *BasicDeliver) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConsumerTag)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 1 + sovProtocolGenerated(uint64(m.DeliveryTag))
	n += 2
	l = len(m.Exchange)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.RoutingKey)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	return n
}

func (m *BasicGet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.Reserved1))
	l = len(m.Queue)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 2
	return n
}

func (m *BasicGetOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.DeliveryTag))
	n += 2
	l = len(m.Exchange)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	l = len(m.RoutingKey)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	n += 1 + sovProtocolGenerated(uint64(m.MessageCount))
	return n
}

func (m *BasicGetEmpty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reserved1)
	n += 1 + l + sovProtocolGenerated(uint64(l))
	return n
}

func (m *BasicAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.DeliveryTag))
	n += 2
	return n
}

func (m *BasicReject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.DeliveryTag))
	n += 2
	return n
}

func (m *BasicRecoverAsync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func (m *BasicRecover) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func (m *BasicRecoverOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *BasicNack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovProtocolGenerated(uint64(m.DeliveryTag))
	n += 2
	n += 2
	return n
}

func (m *TxSelect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TxSelectOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TxCommit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TxCommitOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TxRollback) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TxRollbackOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ConfirmSelect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}

func (m *ConfirmSelectOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovProtocolGenerated(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProtocolGenerated(x uint64) (n int) {
	return sovProtocolGenerated(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ConnectionStart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionStart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionStart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionMajor", wireType)
			}
			m.VersionMajor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionMajor |= byte(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionMinor", wireType)
			}
			m.VersionMinor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VersionMinor |= byte(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerProperties == nil {
				m.ServerProperties = &Table{}
			}
			if err := m.ServerProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mechanisms", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mechanisms = append(m.Mechanisms[:0], dAtA[iNdEx:postIndex]...)
			if m.Mechanisms == nil {
				m.Mechanisms = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locales", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locales = append(m.Locales[:0], dAtA[iNdEx:postIndex]...)
			if m.Locales == nil {
				m.Locales = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionStartOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionStartOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionStartOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientProperties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientProperties == nil {
				m.ClientProperties = &Table{}
			}
			if err := m.ClientProperties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mechanism", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mechanism = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response[:0], dAtA[iNdEx:postIndex]...)
			if m.Response == nil {
				m.Response = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locale = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionSecure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionSecure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionSecure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = append(m.Challenge[:0], dAtA[iNdEx:postIndex]...)
			if m.Challenge == nil {
				m.Challenge = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionSecureOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionSecureOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionSecureOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Response = append(m.Response[:0], dAtA[iNdEx:postIndex]...)
			if m.Response == nil {
				m.Response = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionTune) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionTune: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionTune: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelMax", wireType)
			}
			m.ChannelMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelMax |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameMax", wireType)
			}
			m.FrameMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrameMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			m.Heartbeat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Heartbeat |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionTuneOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionTuneOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionTuneOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelMax", wireType)
			}
			m.ChannelMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelMax |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameMax", wireType)
			}
			m.FrameMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrameMax |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			m.Heartbeat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Heartbeat |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VirtualHost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VirtualHost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserved1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved2", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reserved2 = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionOpenOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionOpenOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionOpenOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserved1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionClose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionClose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionClose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyCode", wireType)
			}
			m.ReplyCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyCode |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodId", wireType)
			}
			m.MethodId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MethodId |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionCloseOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionCloseOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionCloseOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionBlocked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionBlocked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionBlocked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionUnblocked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionUnblocked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionUnblocked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelOpen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelOpen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelOpen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserved1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelOpenOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelOpenOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelOpenOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserved1 = append(m.Reserved1[:0], dAtA[iNdEx:postIndex]...)
			if m.Reserved1 == nil {
				m.Reserved1 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelFlow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelFlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelFlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelFlowOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelFlowOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelFlowOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelClose) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelClose: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelClose: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyCode", wireType)
			}
			m.ReplyCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyCode |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			m.ClassId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClassId |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MethodId", wireType)
			}
			m.MethodId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MethodId |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelCloseOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelCloseOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelCloseOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeDeclare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeDeclare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeDeclare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Passive = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Durable = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoDelete = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Internal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Internal = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWait = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Table{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeDeclareOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeDeclareOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeDeclareOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfUnused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfUnused = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWait = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeDeleteOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeDeleteOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeDeleteOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeBind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeBind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeBind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWait = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Table{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeBindOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeBindOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeBindOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeUnbind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeUnbind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeUnbind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWait = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Table{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeUnbindOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeUnbindOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeUnbindOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueDeclare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueDeclare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueDeclare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Passive = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Durable = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclusive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exclusive = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutoDelete = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWait = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Table{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueDeclareOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueDeclareOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueDeclareOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageCount", wireType)
			}
			m.MessageCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerCount", wireType)
			}
			m.ConsumerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsumerCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueBind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueBind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueBind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWait = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Table{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueBindOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueBindOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueBindOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueUnbind) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueUnbind: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueUnbind: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Table{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueUnbindOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueUnbindOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueUnbindOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuePurge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuePurge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuePurge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWait = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueuePurgeOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueuePurgeOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueuePurgeOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageCount", wireType)
			}
			m.MessageCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfUnused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfUnused = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IfEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IfEmpty = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWait = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueDeleteOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueDeleteOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueDeleteOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageCount", wireType)
			}
			m.MessageCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicContentHeaderProperties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicContentHeaderProperties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicContentHeaderProperties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ContentType = &s
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentEncoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ContentEncoding = &s
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = &Table{}
			}
			if err := m.Headers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryMode", wireType)
			}
			var v byte
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= byte(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DeliveryMode = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			var v byte
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= byte(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Priority = &v
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CorrelationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CorrelationId = &s
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ReplyTo = &s
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Expiration = &s
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.MessageId = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timestamp = &v
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Type = &s
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.UserId = &s
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AppId = &s
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Reserved = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicQos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicQos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicQos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefetchSize", wireType)
			}
			m.PrefetchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefetchSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrefetchCount", wireType)
			}
			m.PrefetchCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrefetchCount |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Global = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicQosOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicQosOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicQosOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicConsume) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicConsume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicConsume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoLocal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoLocal = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoAck = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclusive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exclusive = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWait = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Arguments == nil {
				m.Arguments = &Table{}
			}
			if err := m.Arguments.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicConsumeOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicConsumeOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicConsumeOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicCancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicCancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicCancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoWait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoWait = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicCancelOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicCancelOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicCancelOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicPublish) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicPublish: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicPublish: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mandatory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Mandatory = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Immediate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Immediate = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicReturn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicReturn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicReturn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyCode", wireType)
			}
			m.ReplyCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplyCode |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplyText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplyText = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicDeliver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicDeliver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicDeliver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryTag", wireType)
			}
			m.DeliveryTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryTag |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redelivered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Redelivered = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicGet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicGet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicGet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			m.Reserved1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reserved1 |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoAck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoAck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicGetOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicGetOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicGetOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryTag", wireType)
			}
			m.DeliveryTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryTag |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redelivered", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Redelivered = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoutingKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoutingKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageCount", wireType)
			}
			m.MessageCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicGetEmpty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicGetEmpty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicGetEmpty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reserved1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reserved1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryTag", wireType)
			}
			m.DeliveryTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryTag |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiple", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Multiple = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicReject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicReject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicReject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryTag", wireType)
			}
			m.DeliveryTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryTag |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requeue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Requeue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicRecoverAsync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicRecoverAsync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicRecoverAsync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requeue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Requeue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicRecover) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicRecover: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicRecover: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requeue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Requeue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicRecoverOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicRecoverOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicRecoverOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicNack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicNack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicNack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryTag", wireType)
			}
			m.DeliveryTag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryTag |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiple", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Multiple = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requeue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Requeue = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxSelect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxSelect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxSelect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxSelectOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxSelectOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxSelectOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxCommit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxCommit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxCommit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxCommitOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxCommitOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxCommitOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRollback) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRollback: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRollback: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRollbackOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRollbackOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRollbackOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfirmSelect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfirmSelect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfirmSelect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nowait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nowait = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfirmSelectOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfirmSelectOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfirmSelectOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipProtocolGenerated(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthProtocolGenerated
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProtocolGenerated(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProtocolGenerated
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProtocolGenerated
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProtocolGenerated
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthProtocolGenerated
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProtocolGenerated
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProtocolGenerated(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthProtocolGenerated
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProtocolGenerated = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProtocolGenerated   = fmt.Errorf("proto: integer overflow")
)
