// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/ernestrc/dispatchd/amqp/messages.proto

package amqp

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type WireFrame struct {
	FrameType            uint8    `protobuf:"varint,1,opt,name=frameType,casttype=uint8" json:"frameType"`
	Channel              uint16   `protobuf:"varint,2,opt,name=channel,casttype=uint16" json:"channel"`
	Payload              []byte   `protobuf:"bytes,3,opt,name=payload" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WireFrame) Reset()         { *m = WireFrame{} }
func (m *WireFrame) String() string { return proto.CompactTextString(m) }
func (*WireFrame) ProtoMessage()    {}
func (*WireFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_92dba33e41672625, []int{0}
}
func (m *WireFrame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WireFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WireFrame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WireFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WireFrame.Merge(m, src)
}
func (m *WireFrame) XXX_Size() int {
	return m.Size()
}
func (m *WireFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_WireFrame.DiscardUnknown(m)
}

var xxx_messageInfo_WireFrame proto.InternalMessageInfo

type IndexMessage struct {
	// The ID of the underlying message
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id"`
	// The number of outstanding references to the message
	Refs                 int32    `protobuf:"varint,2,opt,name=refs" json:"refs"`
	Durable              bool     `protobuf:"varint,3,opt,name=durable" json:"durable"`
	DeliveryCount        int32    `protobuf:"varint,4,opt,name=deliveryCount" json:"deliveryCount"`
	Persisted            bool     `protobuf:"varint,5,opt,name=persisted" json:"persisted"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IndexMessage) Reset()         { *m = IndexMessage{} }
func (m *IndexMessage) String() string { return proto.CompactTextString(m) }
func (*IndexMessage) ProtoMessage()    {}
func (*IndexMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_92dba33e41672625, []int{1}
}
func (m *IndexMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexMessage.Merge(m, src)
}
func (m *IndexMessage) XXX_Size() int {
	return m.Size()
}
func (m *IndexMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexMessage.DiscardUnknown(m)
}

var xxx_messageInfo_IndexMessage proto.InternalMessageInfo

func (m *IndexMessage) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *IndexMessage) GetRefs() int32 {
	if m != nil {
		return m.Refs
	}
	return 0
}

func (m *IndexMessage) GetDurable() bool {
	if m != nil {
		return m.Durable
	}
	return false
}

func (m *IndexMessage) GetDeliveryCount() int32 {
	if m != nil {
		return m.DeliveryCount
	}
	return 0
}

func (m *IndexMessage) GetPersisted() bool {
	if m != nil {
		return m.Persisted
	}
	return false
}

type Message struct {
	Id                   int64               `protobuf:"varint,1,opt,name=id" json:"id"`
	Header               *ContentHeaderFrame `protobuf:"bytes,2,opt,name=header" json:"header,omitempty"`
	Payload              []*WireFrame        `protobuf:"bytes,3,rep,name=payload" json:"payload,omitempty"`
	Exchange             string              `protobuf:"bytes,4,opt,name=exchange" json:"exchange"`
	Key                  string              `protobuf:"bytes,5,opt,name=key" json:"key"`
	Method               *BasicPublish       `protobuf:"bytes,6,opt,name=method" json:"method,omitempty"`
	Redelivered          uint32              `protobuf:"varint,7,opt,name=redelivered" json:"redelivered"`
	LocalId              int64               `protobuf:"varint,8,opt,name=local_id,json=localId" json:"local_id"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_92dba33e41672625, []int{2}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Message) GetHeader() *ContentHeaderFrame {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Message) GetPayload() []*WireFrame {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Message) GetExchange() string {
	if m != nil {
		return m.Exchange
	}
	return ""
}

func (m *Message) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Message) GetMethod() *BasicPublish {
	if m != nil {
		return m.Method
	}
	return nil
}

func (m *Message) GetRedelivered() uint32 {
	if m != nil {
		return m.Redelivered
	}
	return 0
}

func (m *Message) GetLocalId() int64 {
	if m != nil {
		return m.LocalId
	}
	return 0
}

type QueueMessage struct {
	Id                   int64    `protobuf:"varint,1,opt,name=id" json:"id"`
	DeliveryCount        int32    `protobuf:"varint,2,opt,name=deliveryCount" json:"deliveryCount"`
	Durable              bool     `protobuf:"varint,3,opt,name=durable" json:"durable"`
	MsgSize              uint32   `protobuf:"varint,4,opt,name=msgSize" json:"msgSize"`
	LocalId              int64    `protobuf:"varint,5,opt,name=localId" json:"localId"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueueMessage) Reset()         { *m = QueueMessage{} }
func (m *QueueMessage) String() string { return proto.CompactTextString(m) }
func (*QueueMessage) ProtoMessage()    {}
func (*QueueMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_92dba33e41672625, []int{3}
}
func (m *QueueMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueMessage.Merge(m, src)
}
func (m *QueueMessage) XXX_Size() int {
	return m.Size()
}
func (m *QueueMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueMessage.DiscardUnknown(m)
}

var xxx_messageInfo_QueueMessage proto.InternalMessageInfo

func (m *QueueMessage) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *QueueMessage) GetDeliveryCount() int32 {
	if m != nil {
		return m.DeliveryCount
	}
	return 0
}

func (m *QueueMessage) GetDurable() bool {
	if m != nil {
		return m.Durable
	}
	return false
}

func (m *QueueMessage) GetMsgSize() uint32 {
	if m != nil {
		return m.MsgSize
	}
	return 0
}

func (m *QueueMessage) GetLocalId() int64 {
	if m != nil {
		return m.LocalId
	}
	return 0
}

type ContentHeaderFrame struct {
	ContentClass         uint16                        `protobuf:"varint,1,opt,name=content_class,json=contentClass,casttype=uint16" json:"content_class"`
	ContentWeight        uint16                        `protobuf:"varint,2,opt,name=content_weight,json=contentWeight,casttype=uint16" json:"content_weight"`
	ContentBodySize      uint64                        `protobuf:"varint,3,opt,name=content_body_size,json=contentBodySize" json:"content_body_size"`
	PropertyFlags        uint16                        `protobuf:"varint,4,opt,name=property_flags,json=propertyFlags,casttype=uint16" json:"property_flags"`
	Properties           *BasicContentHeaderProperties `protobuf:"bytes,5,opt,name=properties" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *ContentHeaderFrame) Reset()         { *m = ContentHeaderFrame{} }
func (m *ContentHeaderFrame) String() string { return proto.CompactTextString(m) }
func (*ContentHeaderFrame) ProtoMessage()    {}
func (*ContentHeaderFrame) Descriptor() ([]byte, []int) {
	return fileDescriptor_92dba33e41672625, []int{4}
}
func (m *ContentHeaderFrame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContentHeaderFrame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContentHeaderFrame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContentHeaderFrame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentHeaderFrame.Merge(m, src)
}
func (m *ContentHeaderFrame) XXX_Size() int {
	return m.Size()
}
func (m *ContentHeaderFrame) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentHeaderFrame.DiscardUnknown(m)
}

var xxx_messageInfo_ContentHeaderFrame proto.InternalMessageInfo

func (m *ContentHeaderFrame) GetContentClass() uint16 {
	if m != nil {
		return m.ContentClass
	}
	return 0
}

func (m *ContentHeaderFrame) GetContentWeight() uint16 {
	if m != nil {
		return m.ContentWeight
	}
	return 0
}

func (m *ContentHeaderFrame) GetContentBodySize() uint64 {
	if m != nil {
		return m.ContentBodySize
	}
	return 0
}

func (m *ContentHeaderFrame) GetPropertyFlags() uint16 {
	if m != nil {
		return m.PropertyFlags
	}
	return 0
}

func (m *ContentHeaderFrame) GetProperties() *BasicContentHeaderProperties {
	if m != nil {
		return m.Properties
	}
	return nil
}

type TxMessage struct {
	Msg                  *Message `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
	QueueName            string   `protobuf:"bytes,2,opt,name=queue_name,json=queueName" json:"queue_name"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxMessage) Reset()         { *m = TxMessage{} }
func (m *TxMessage) String() string { return proto.CompactTextString(m) }
func (*TxMessage) ProtoMessage()    {}
func (*TxMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_92dba33e41672625, []int{5}
}
func (m *TxMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxMessage.Merge(m, src)
}
func (m *TxMessage) XXX_Size() int {
	return m.Size()
}
func (m *TxMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TxMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TxMessage proto.InternalMessageInfo

func (m *TxMessage) GetMsg() *Message {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *TxMessage) GetQueueName() string {
	if m != nil {
		return m.QueueName
	}
	return ""
}

type TxAck struct {
	Tag                  uint64   `protobuf:"varint,1,opt,name=tag" json:"tag"`
	Multiple             bool     `protobuf:"varint,2,opt,name=multiple" json:"multiple"`
	Nack                 bool     `protobuf:"varint,3,opt,name=nack" json:"nack"`
	RequeueNack          bool     `protobuf:"varint,4,opt,name=requeue_nack,json=requeueNack" json:"requeue_nack"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxAck) Reset()         { *m = TxAck{} }
func (m *TxAck) String() string { return proto.CompactTextString(m) }
func (*TxAck) ProtoMessage()    {}
func (*TxAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_92dba33e41672625, []int{6}
}
func (m *TxAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxAck.Merge(m, src)
}
func (m *TxAck) XXX_Size() int {
	return m.Size()
}
func (m *TxAck) XXX_DiscardUnknown() {
	xxx_messageInfo_TxAck.DiscardUnknown(m)
}

var xxx_messageInfo_TxAck proto.InternalMessageInfo

func (m *TxAck) GetTag() uint64 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *TxAck) GetMultiple() bool {
	if m != nil {
		return m.Multiple
	}
	return false
}

func (m *TxAck) GetNack() bool {
	if m != nil {
		return m.Nack
	}
	return false
}

func (m *TxAck) GetRequeueNack() bool {
	if m != nil {
		return m.RequeueNack
	}
	return false
}

type UnackedMessage struct {
	ConsumerTag          string        `protobuf:"bytes,1,opt,name=consumer_tag,json=consumerTag" json:"consumer_tag"`
	Msg                  *QueueMessage `protobuf:"bytes,2,opt,name=msg" json:"msg,omitempty"`
	QueueName            string        `protobuf:"bytes,3,opt,name=queue_name,json=queueName" json:"queue_name"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UnackedMessage) Reset()         { *m = UnackedMessage{} }
func (m *UnackedMessage) String() string { return proto.CompactTextString(m) }
func (*UnackedMessage) ProtoMessage()    {}
func (*UnackedMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_92dba33e41672625, []int{7}
}
func (m *UnackedMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnackedMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnackedMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnackedMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnackedMessage.Merge(m, src)
}
func (m *UnackedMessage) XXX_Size() int {
	return m.Size()
}
func (m *UnackedMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UnackedMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UnackedMessage proto.InternalMessageInfo

func (m *UnackedMessage) GetConsumerTag() string {
	if m != nil {
		return m.ConsumerTag
	}
	return ""
}

func (m *UnackedMessage) GetMsg() *QueueMessage {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *UnackedMessage) GetQueueName() string {
	if m != nil {
		return m.QueueName
	}
	return ""
}

func init() {
	proto.RegisterType((*WireFrame)(nil), "amqp.WireFrame")
	proto.RegisterType((*IndexMessage)(nil), "amqp.IndexMessage")
	proto.RegisterType((*Message)(nil), "amqp.Message")
	proto.RegisterType((*QueueMessage)(nil), "amqp.QueueMessage")
	proto.RegisterType((*ContentHeaderFrame)(nil), "amqp.ContentHeaderFrame")
	proto.RegisterType((*TxMessage)(nil), "amqp.TxMessage")
	proto.RegisterType((*TxAck)(nil), "amqp.TxAck")
	proto.RegisterType((*UnackedMessage)(nil), "amqp.UnackedMessage")
}

func init() {
	proto.RegisterFile("github.com/ernestrc/dispatchd/amqp/messages.proto", fileDescriptor_92dba33e41672625)
}

var fileDescriptor_92dba33e41672625 = []byte{
	// 771 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0xcb, 0x6e, 0x23, 0x45,
	0x14, 0x4d, 0xfb, 0xed, 0xeb, 0xc7, 0x88, 0x12, 0x42, 0xad, 0x59, 0xd8, 0x51, 0x83, 0x18, 0x33,
	0x08, 0x7b, 0xc6, 0x68, 0x10, 0x82, 0x15, 0x8e, 0x14, 0x91, 0x05, 0x28, 0x69, 0x8c, 0xb2, 0xb4,
	0xca, 0x5d, 0xd7, 0xed, 0x96, 0xfb, 0x95, 0xaa, 0x6e, 0x88, 0x59, 0x23, 0xc4, 0x67, 0xc0, 0x1a,
	0x81, 0xf8, 0x8c, 0x2c, 0xf3, 0x05, 0x11, 0xca, 0x67, 0xb0, 0x42, 0x55, 0x5d, 0xe5, 0x74, 0x70,
	0x12, 0xd8, 0xb9, 0xcf, 0x39, 0x75, 0xeb, 0xdc, 0x73, 0x6f, 0x19, 0x5e, 0xfb, 0x41, 0xb6, 0xce,
	0x97, 0x63, 0x2f, 0x89, 0x26, 0xc8, 0x63, 0x14, 0x19, 0xf7, 0x26, 0x2c, 0x10, 0x29, 0xcd, 0xbc,
	0x35, 0x9b, 0xd0, 0xe8, 0x22, 0x9d, 0x44, 0x28, 0x04, 0xf5, 0x51, 0x8c, 0x53, 0x9e, 0x64, 0x09,
	0xa9, 0x49, 0xf0, 0xf9, 0x47, 0xa5, 0x83, 0x7e, 0xe2, 0x27, 0x13, 0x45, 0x2e, 0xf3, 0x95, 0xfa,
	0x52, 0x1f, 0xea, 0x57, 0x71, 0xe8, 0xf9, 0xe7, 0xff, 0xe3, 0x1e, 0xa5, 0xf4, 0x92, 0x70, 0xe1,
	0x63, 0x8c, 0x9c, 0x66, 0xc8, 0x8a, 0xc3, 0xce, 0x4f, 0x16, 0xb4, 0xcf, 0x03, 0x8e, 0xc7, 0x9c,
	0x46, 0x48, 0x3e, 0x84, 0xf6, 0x4a, 0xfe, 0x98, 0x6f, 0x53, 0xb4, 0xad, 0x43, 0x6b, 0xd4, 0x9b,
	0xf5, 0xae, 0x6e, 0x86, 0x07, 0x7f, 0xdf, 0x0c, 0xeb, 0x79, 0x10, 0x67, 0x9f, 0xba, 0x77, 0x3c,
	0x19, 0x41, 0xd3, 0x5b, 0xd3, 0x38, 0xc6, 0xd0, 0xae, 0x28, 0x69, 0x5f, 0x4b, 0x1b, 0x52, 0xfa,
	0xfa, 0x13, 0xd7, 0xd0, 0xc4, 0x86, 0x66, 0x4a, 0xb7, 0x61, 0x42, 0x99, 0x5d, 0x3d, 0xb4, 0x46,
	0x5d, 0xd7, 0x7c, 0x7e, 0xd6, 0xfa, 0xf9, 0x97, 0xe1, 0xc1, 0xf5, 0xaf, 0xc3, 0x03, 0xe7, 0x0f,
	0x0b, 0xba, 0x27, 0x31, 0xc3, 0xcb, 0xaf, 0x8a, 0x48, 0xc8, 0xdb, 0x50, 0x09, 0x98, 0x32, 0x51,
	0x9d, 0xd5, 0x64, 0x65, 0xb7, 0x12, 0x30, 0x62, 0x43, 0x8d, 0xe3, 0x4a, 0xa8, 0x1b, 0xeb, 0x1a,
	0x57, 0x08, 0x19, 0x40, 0x93, 0xe5, 0x9c, 0x2e, 0x43, 0x54, 0x97, 0xb4, 0x34, 0x69, 0x40, 0xf2,
	0x12, 0x7a, 0x0c, 0xc3, 0xe0, 0x3b, 0xe4, 0xdb, 0xa3, 0x24, 0x8f, 0x33, 0xbb, 0x56, 0x2a, 0x71,
	0x9f, 0x22, 0x0e, 0xb4, 0x53, 0xe4, 0x22, 0x10, 0x19, 0x32, 0xbb, 0x5e, 0xaa, 0x76, 0x07, 0x3b,
	0xbf, 0x55, 0xa0, 0xf9, 0xb4, 0xd7, 0x57, 0xd0, 0x58, 0x23, 0x65, 0xc8, 0x95, 0xdb, 0xce, 0xd4,
	0x1e, 0xcb, 0x59, 0x8c, 0x8f, 0x92, 0x38, 0xc3, 0x38, 0xfb, 0x52, 0x51, 0x2a, 0x77, 0x57, 0xeb,
	0xc8, 0x07, 0xe5, 0xa0, 0xaa, 0xa3, 0xce, 0xf4, 0x59, 0x71, 0x64, 0x37, 0xa1, 0x5d, 0x72, 0xe4,
	0x10, 0x5a, 0x78, 0x29, 0x03, 0xf6, 0x51, 0x75, 0xd2, 0xd6, 0x17, 0xef, 0x50, 0xf2, 0x0e, 0x54,
	0x37, 0xb8, 0x55, 0xf6, 0x0d, 0x29, 0x01, 0xf2, 0x12, 0x1a, 0x11, 0x66, 0xeb, 0x84, 0xd9, 0x0d,
	0x65, 0x8b, 0x14, 0x77, 0xcc, 0xa8, 0x08, 0xbc, 0xd3, 0x7c, 0x19, 0x06, 0x62, 0xed, 0x6a, 0x05,
	0x79, 0x1f, 0x3a, 0x1c, 0x75, 0x36, 0xc8, 0xec, 0xa6, 0x9a, 0x73, 0x51, 0xab, 0x4c, 0x90, 0x21,
	0xb4, 0xc2, 0xc4, 0xa3, 0xe1, 0x22, 0x60, 0x76, 0xab, 0x14, 0x43, 0x53, 0xa1, 0x27, 0xcc, 0xf9,
	0xd3, 0x82, 0xee, 0x59, 0x8e, 0x39, 0x3e, 0x1d, 0xd9, 0xde, 0x90, 0x2a, 0x8f, 0x0f, 0xe9, 0xbf,
	0x06, 0x3e, 0x80, 0x66, 0x24, 0xfc, 0x6f, 0x82, 0x1f, 0x8a, 0x80, 0x8c, 0x6f, 0x03, 0x4a, 0x5e,
	0xbb, 0x53, 0x19, 0xed, 0x59, 0xfe, 0xbd, 0x02, 0x64, 0x7f, 0x56, 0xe4, 0x63, 0xe8, 0x79, 0x05,
	0xba, 0xf0, 0x42, 0x2a, 0x84, 0x7e, 0x27, 0xff, 0x5e, 0xfe, 0xae, 0x16, 0x1d, 0x49, 0x0d, 0x79,
	0x03, 0x7d, 0x73, 0xe8, 0x7b, 0x0c, 0xfc, 0x75, 0xf6, 0xc8, 0x93, 0x31, 0xa5, 0xcf, 0x95, 0x88,
	0xbc, 0x82, 0xb7, 0xcc, 0xb1, 0x65, 0xc2, 0xb6, 0x0b, 0x21, 0x9b, 0x91, 0xcd, 0xd6, 0xb4, 0xd9,
	0x67, 0x9a, 0x9e, 0x25, 0x6c, 0xab, 0x9a, 0x7a, 0x03, 0xfd, 0x94, 0x27, 0x29, 0xf2, 0x6c, 0xbb,
	0x58, 0x85, 0xd4, 0x17, 0xba, 0xf7, 0xbd, 0x8b, 0x8c, 0xea, 0x58, 0x8a, 0xc8, 0x0c, 0x40, 0x03,
	0x01, 0x0a, 0x15, 0x47, 0x67, 0xea, 0x94, 0xf6, 0xe2, 0x5e, 0x0e, 0xa7, 0x3b, 0xa5, 0x5b, 0x3a,
	0xe5, 0x9c, 0x41, 0x7b, 0xbe, 0x7b, 0xbd, 0x43, 0xa8, 0x46, 0xc2, 0x57, 0xd9, 0x74, 0xa6, 0xbd,
	0xa2, 0x92, 0xe6, 0x5c, 0xc9, 0x90, 0x77, 0x01, 0x2e, 0xe4, 0x3e, 0x2c, 0x62, 0x1a, 0xa1, 0x4a,
	0xc3, 0x2c, 0x69, 0x5b, 0xe1, 0x5f, 0xd3, 0x08, 0x9d, 0x1f, 0x2d, 0xa8, 0xcf, 0x2f, 0xbf, 0xf0,
	0x36, 0x72, 0x99, 0x33, 0x5a, 0xd4, 0x33, 0xbd, 0x4b, 0x40, 0x3e, 0x83, 0x28, 0x0f, 0xb3, 0x20,
	0x0d, 0x8b, 0x22, 0x66, 0x0b, 0x76, 0xa8, 0xfc, 0xc7, 0x88, 0xa9, 0xb7, 0xb9, 0xb7, 0x23, 0x0a,
	0x21, 0x2f, 0xa0, 0xcb, 0xd1, 0x98, 0xf0, 0x36, 0x2a, 0xa9, 0xd6, 0xdd, 0x76, 0x6b, 0x1b, 0xde,
	0x46, 0xda, 0xe8, 0x7f, 0x2b, 0x25, 0xc8, 0x4c, 0x7f, 0x2f, 0x40, 0x0e, 0x58, 0xe4, 0x11, 0xf2,
	0x85, 0x31, 0x66, 0x1a, 0xe8, 0x18, 0x66, 0x4e, 0x7d, 0xf2, 0x5e, 0x11, 0x44, 0xa5, 0xfc, 0xd4,
	0xca, 0x0f, 0xe1, 0xa1, 0x34, 0xaa, 0x0f, 0xa6, 0x31, 0xeb, 0x5e, 0xdd, 0x0e, 0xac, 0xeb, 0xdb,
	0x81, 0xf5, 0xd7, 0xed, 0xc0, 0xfa, 0x27, 0x00, 0x00, 0xff, 0xff, 0xc6, 0x7d, 0xfc, 0x3f, 0x5f,
	0x06, 0x00, 0x00,
}

func (m *WireFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WireFrame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.FrameType))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.Channel))
	if m.Payload != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *IndexMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.Refs))
	dAtA[i] = 0x18
	i++
	if m.Durable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.DeliveryCount))
	dAtA[i] = 0x28
	i++
	if m.Persisted {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.Id))
	if m.Header != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Header.Size()))
		n1, err1 := m.Header.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if len(m.Payload) > 0 {
		for _, msg := range m.Payload {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMessages(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.Exchange)))
	i += copy(dAtA[i:], m.Exchange)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.Key)))
	i += copy(dAtA[i:], m.Key)
	if m.Method != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Method.Size()))
		n2, err2 := m.Method.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.Redelivered))
	dAtA[i] = 0x40
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.LocalId))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueueMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.DeliveryCount))
	dAtA[i] = 0x18
	i++
	if m.Durable {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.MsgSize))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.LocalId))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContentHeaderFrame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentHeaderFrame) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.ContentClass))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.ContentWeight))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.ContentBodySize))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.PropertyFlags))
	if m.Properties != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Properties.Size()))
		n3, err3 := m.Properties.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Msg != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Msg.Size()))
		n4, err4 := m.Msg.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.QueueName)))
	i += copy(dAtA[i:], m.QueueName)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxAck) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMessages(dAtA, i, uint64(m.Tag))
	dAtA[i] = 0x10
	i++
	if m.Multiple {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x18
	i++
	if m.Nack {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x20
	i++
	if m.RequeueNack {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UnackedMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnackedMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.ConsumerTag)))
	i += copy(dAtA[i:], m.ConsumerTag)
	if m.Msg != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMessages(dAtA, i, uint64(m.Msg.Size()))
		n5, err5 := m.Msg.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMessages(dAtA, i, uint64(len(m.QueueName)))
	i += copy(dAtA[i:], m.QueueName)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMessages(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *WireFrame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMessages(uint64(m.FrameType))
	n += 1 + sovMessages(uint64(m.Channel))
	if m.Payload != nil {
		l = len(m.Payload)
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *IndexMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMessages(uint64(m.Id))
	n += 1 + sovMessages(uint64(m.Refs))
	n += 2
	n += 1 + sovMessages(uint64(m.DeliveryCount))
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMessages(uint64(m.Id))
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Payload) > 0 {
		for _, e := range m.Payload {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Exchange)
	n += 1 + l + sovMessages(uint64(l))
	l = len(m.Key)
	n += 1 + l + sovMessages(uint64(l))
	if m.Method != nil {
		l = m.Method.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	n += 1 + sovMessages(uint64(m.Redelivered))
	n += 1 + sovMessages(uint64(m.LocalId))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueueMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMessages(uint64(m.Id))
	n += 1 + sovMessages(uint64(m.DeliveryCount))
	n += 2
	n += 1 + sovMessages(uint64(m.MsgSize))
	n += 1 + sovMessages(uint64(m.LocalId))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContentHeaderFrame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMessages(uint64(m.ContentClass))
	n += 1 + sovMessages(uint64(m.ContentWeight))
	n += 1 + sovMessages(uint64(m.ContentBodySize))
	n += 1 + sovMessages(uint64(m.PropertyFlags))
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.QueueName)
	n += 1 + l + sovMessages(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovMessages(uint64(m.Tag))
	n += 2
	n += 2
	n += 2
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnackedMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConsumerTag)
	n += 1 + l + sovMessages(uint64(l))
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.QueueName)
	n += 1 + l + sovMessages(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMessages(x uint64) (n int) {
	return sovMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WireFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WireFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WireFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameType", wireType)
			}
			m.FrameType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrameType |= uint8(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refs", wireType)
			}
			m.Refs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Refs |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Durable = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryCount", wireType)
			}
			m.DeliveryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Persisted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Persisted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ContentHeaderFrame{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, &WireFrame{})
			if err := m.Payload[len(m.Payload)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Method == nil {
				m.Method = &BasicPublish{}
			}
			if err := m.Method.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redelivered", wireType)
			}
			m.Redelivered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Redelivered |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalId", wireType)
			}
			m.LocalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryCount", wireType)
			}
			m.DeliveryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeliveryCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Durable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Durable = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgSize", wireType)
			}
			m.MsgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalId", wireType)
			}
			m.LocalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentHeaderFrame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentHeaderFrame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentHeaderFrame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentClass", wireType)
			}
			m.ContentClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentClass |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentWeight", wireType)
			}
			m.ContentWeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentWeight |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentBodySize", wireType)
			}
			m.ContentBodySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentBodySize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PropertyFlags", wireType)
			}
			m.PropertyFlags = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PropertyFlags |= uint16(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &BasicContentHeaderProperties{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &Message{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiple", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Multiple = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nack", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nack = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequeueNack", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequeueNack = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnackedMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnackedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnackedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsumerTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsumerTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &QueueMessage{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessages
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessages(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessages
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessages(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMessages
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessages   = fmt.Errorf("proto: integer overflow")
)
